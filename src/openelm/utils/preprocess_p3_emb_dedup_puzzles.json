[
    {
        "program_str": "def f(n: int) -> bool:\n    return str(n * n).startswith('123456789')\ndef g():\n    return int(int(\"123456789\" + \"0\" * 9) ** 0.5) + 1\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and string manipulation.",
        "description": "Find the solution: n (integer) that should be squared to produce a number whose string representation starts with '123456789'.",
        "quality": 1,
        "fitness": 0.591924250125885
    },
    {
        "program_str": "def f(s: str) -> bool:\n    return s.count('o') == 1000 and s.count('oo') == 0\ndef g():\n    return ('h' + 'o') * 1000\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: s (a string) that should have exactly 1000 occurrences of the letter 'o' and no occurrences of the substring 'oo'.",
        "quality": 1,
        "fitness": 0.6244425773620605
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return sorted(li) == list(range(999)) and all((li[i] != i for i in range(len(li))))\ndef g():\n    return [((i + 1) % 999) for i in range(999)]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list and checking for a specific condition on the elements of the list.",
        "description": "Find the solution: list of integers that should be sorted in ascending order and contain all integers from 0 to 998 without any duplicates.",
        "quality": 1,
        "fitness": 0.5546687841415405
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all([li.count(i) == i for i in range(10)])\ndef g():\n    return [i for i in range(10) for j in range(i)]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and checking for a specific condition using list comprehension.",
        "description": "Find the solution: `li` (a list of integers) that should have each integer `i` appearing exactly `i` times in the list.",
        "quality": 1,
        "fitness": 0.5951239466667175
    },
    {
        "program_str": "def f(s: str) -> bool:\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3\ndef g():\n    s = str(8 ** 2888)\n    return max({s[i: i + 3] for i in range(len(s) - 2)}, key=lambda t: s.count(t))\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations.",
        "description": "Find the solution: s (a string) that should have a count greater than 8 in the string representation of 8 raised to the power of 2888, and its length should be 3.",
        "quality": 1,
        "fitness": 0.5410199165344238
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return ['The quick brown fox jumps over the lazy dog'[i] for i in li] == list('The five boxing wizards jump quickly')\ndef g():\n    return ['The quick brown fox jumps over the lazy dog'.index(t)\n            for t in 'The five boxing wizards jump quickly']\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and list operations. It also requires understanding of list comprehension and indexing in Python.",
        "description": "Find the solution: list of integers that should map to specific characters in a string to match another given string.",
        "quality": 1,
        "fitness": 0.5982599854469299
    },
    {
        "program_str": "from typing import List \ndef f(ls: List[str]) -> bool:\n    return min(ls) == max(ls) == str(len(ls))\ndef g():\n    return ['1']\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and list operations.",
        "description": "Find the solution: list of strings (ls) that should contain only one element which is the string representation of the length of the list.",
        "quality": 1,
        "fitness": 0.5812702178955078
    },
    {
        "program_str": "def f(x: float) -> bool:\n    return str(x - 3.1415).startswith('123.456')\ndef g():\n    return 123.456 + 3.1415\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and mathematical operations.",
        "description": "Find the solution: x (a float) that should satisfy the condition where str(x - 3.1415) starts with '123.456'.",
        "quality": 1,
        "fitness": 0.602070152759552
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all((sum(li[:i]) == 2 ** i - 1 for i in range(20)))\ndef g():\n    return [(2 ** i) for i in range(20)]\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list manipulation, and conditional logic.",
        "description": "Find the solution: list of integers `li` that should satisfy the condition where the sum of the first `i` elements in the list equals `2 ** i - 1` for all `i` from 0 to 19.",
        "quality": 1,
        "fitness": 0.6040641069412231
    },
    {
        "program_str": "def f(i: int) -> bool:\n    return len(str(i + 1000)) > len(str(i + 1001))\ndef g():\n    return -1001\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and mathematical operations.",
        "description": "Find the solution: an integer `i` that should satisfy the condition where the length of the string representation of `i + 1000` is greater than the length of the string representation of `i + 1001`.",
        "quality": 1,
        "fitness": 0.5819652080535889
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}\ndef g():\n    return [0, 1, 2, 3, 17]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves set operations and list comprehension to check if the sum of all pairs of elements in the list is equal to a specific set.",
        "description": "Find the solution: list of integers `li` that should contain unique elements such that the sum of any two elements in the list equals one of the specified values in the puzzle.",
        "quality": 1,
        "fitness": 0.5338699221611023
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3\ndef g():\n    return list(range(3)) * 10\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and checking for unique elements in the list.",
        "description": "Find the solution: list of integers `li` that should have 10 elements where each element is different from its adjacent element, and the list should contain exactly 3 unique values.",
        "quality": 1,
        "fitness": 0.5832133889198303
    },
    {
        "program_str": "from typing import List \ndef f(ls: List[str]) -> bool:\n    return tuple(ls) in zip('dee', 'doo', 'dah!')\ndef g():\n    return list(next(zip('dee', 'doo', 'dah!')))\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and list operations.",
        "description": "Find the solution: list of strings (ls) that should match the tuple formed by zipping the strings 'dee', 'doo', 'dah' in order to solve the puzzle.",
        "quality": 1,
        "fitness": 0.596504271030426
    },
    {
        "program_str": "def f(s: str) -> bool:\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]\ndef g():\n    s = sorted('Permute me true'[1:])[::2]\n    return \"\".join(s + ['P'] + s[::-1])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, sorting and ordering, and conditional logic.",
        "description": "Find the solution: s (a string) that should be a permutation of the string 'Permute me true' and a palindrome.",
        "quality": 1,
        "fitness": 0.5515322089195251
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int]) -> bool:\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]\ndef g():\n    return [1, 2, 3, 3]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and conditional logic.",
        "description": "Find the solution: list of integers `li` that should satisfy the conditions where `li[li[0]]` is not equal to `li[li[1]` and `li[li[li[0]]]` is equal to `li[li[li[1]]]`.",
        "quality": 1,
        "fitness": 0.5805121660232544
    },
    {
        "program_str": "from typing import List \ndef f(l: List[int]) -> bool:\n    return all((i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j)) and len(set(l)) > 995\ndef g():\n    return [0, 4] + list(range(6, 1000))\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, list operations, and set operations.",
        "description": "Find the solution: a list of integers that should satisfy the constraints of being within a certain range, having a minimum absolute difference between squares, and containing mostly unique elements.",
        "quality": 1,
        "fitness": 0.5255873799324036
    },
    {
        "program_str": "from typing import List \ndef f(hands: List[int], target_angle=68) -> bool:\n    (h, m) = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]\ndef g(target_angle = 68):\n    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves calculating angles and checking if they match a target angle. It also includes loops and conditional logic to find the correct time. The solution iterates through all possible times to find the correct time that matches the target angle.",
        "description": "Find the solution: a list of two integers representing the hour and minute hands of a clock, where the goal is to determine if the angle between the hour and minute hands matches the target angle specified in the function.",
        "quality": 1,
        "fitness": 0.5331090092658997
    },
    {
        "program_str": "from typing import List \ndef f(daygroups: List[List[List[int]]]) -> bool:\n    assert len(daygroups) == 7\n    assert all((len(groups) == 5 and {i for g in groups for i in g} == set(range(15)) for groups in daygroups))\n    assert all((len(g) == 3 for groups in daygroups for g in groups))\n    return len({(i, j) for groups in daygroups for g in groups for i in g for j in g}) == 15 * 15\ndef g():\n    from itertools import combinations\n    import random\n    rand = random.Random(0)\n    days = [[list(range(15)) for _2 in range(2)] for _ in range(7)]  # each day is pi, inv\n    counts = {(i, j): (7 if j in range(k, k + 3) else 0)\n              for k in range(0, 15, 3)\n              for i in range(k, k + 3)\n              for j in range(15) if j != i\n              }\n\n    todos = [pair for pair, count in counts.items() if count == 0]\n    while True:\n        pair = rand.choice(todos)  # choose i and j to make next to each other on some day\n        if rand.randrange(2):\n            pair = pair[::-1]\n\n        a, u = pair\n        pi, inv = rand.choice(days)\n        assert pi[inv[a]] == a and pi[inv[u]] == u\n        bases = [3 * (inv[i] // 3) for i in pair]\n        (b, c), (v, w) = [[x for x in pi[b: b + 3] if x != i] for i, b in zip(pair, bases)]\n        if rand.randrange(2):\n            b, c, = c, b\n        # current (a, b, c) (u, v, w). consider swap of u with b to make (a, u, c) (b, v, w)\n\n        new_pairs = [(a, u), (c, u), (b, v), (b, w)]\n        old_pairs = [(u, v), (u, w), (b, a), (b, c)]\n        gained = sum(counts[p] == 0 for p in new_pairs)\n        lost = sum(counts[p] == 1 for p in old_pairs)\n        if rand.random() <= 100 ** (gained - lost):\n            for p in new_pairs:\n                counts[p] += 1\n                counts[p[::-1]] += 1\n            for p in old_pairs:\n                counts[p] -= 1\n                counts[p[::-1]] -= 1\n            pi[inv[b]], pi[inv[u]], inv[b], inv[u] = u, b, inv[u], inv[b]\n            todos = [pair for pair, count in counts.items() if count == 0]\n            if len(todos) == 0:\n                return [[pi[k:k + 3] for k in range(0, 15, 3)] for pi, _inv in days]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves a combination of set operations, randomization, and algorithm optimization to solve a scheduling problem.",
        "description": "Find the solution: daygroups (a list of lists of lists of integers) that should contain 7 groups, each with 5 subgroups of 3 integers, where each integer is unique across all groups and subgroups, forming a total of 15 unique integers.",
        "quality": 1,
        "fitness": 0.4925065040588379
    },
    {
        "program_str": "def f(n: int) -> bool:\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1\ndef g():\n    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic, loops, and mathematical operations.",
        "description": "Find the solution: n (integer) that should satisfy the condition n % 5 == 1 and the iterative formula n -= 1 + (n - 1) // 5 for 5 iterations, resulting in n > 0 and n % 5 == 1.",
        "quality": 1,
        "fitness": 0.541561484336853
    },
    {
        "program_str": "from typing import List \ndef f(coords: List[List[int]], side=10, num_points=20) -> bool:\n    for i1 in range(len(coords)):\n        (x1, y1) = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            (x2, y2) = coords[i2]\n            for i3 in range(i2):\n                (x3, y3) = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for (a, b) in coords}) == len(coords) >= num_points\ndef g(side = 10, num_points = 20):\n    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometry and coordinate manipulation to solve a combinatorial problem. It also includes conditional logic and set operations to check for certain conditions and manipulate sets of coordinates.",
        "description": "Find the solution: coords (list of lists of integers) that should form a set of unique points within a specified side length, and no three points should be collinear. The number of points should be greater than or equal to a specified threshold.",
        "quality": 1,
        "fitness": 0.4366503655910492
    },
    {
        "program_str": "from typing import List \ndef f(stamps: List[int], target=271, max_stamps=8, options=[37, 37, 12, 87, 39]) -> bool:\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target\ndef g(target = 271, max_stamps = 8, options = [37, 37, 12, 87, 39]):\n    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, iteration, and combination generation to find a solution that satisfies certain conditions. It also includes assertions for input validation. The solution uses itertools for combination generation and a loop to find the correct combination that sums up to the target value.",
        "description": "Find the solution: stamps (List[int]) that should sum up to the target value (271), with a maximum number of stamps (8) and choosing from a set of options ([37, 37, 12, 87, 39]), ensuring all stamps are within the available options and the total sum is equal to the target value.",
        "quality": 1,
        "fitness": 0.4734683334827423
    },
    {
        "program_str": "from typing import List \ndef f(xy_sides: List[List[int]]) -> bool:\n    n = max((x + side for (x, y, side) in xy_sides))\n    assert len({side for (x, y, side) in xy_sides}) == len(xy_sides) > 1\n    for (x, y, s) in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for (x2, y2, s2) in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or (y2 >= y + s) or (y2 + s2 <= y)\n    return sum((side ** 2 for (x, y, side) in xy_sides)) == n ** 2\ndef g():\n    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves geometric calculations and constraints, such as checking the validity of overlapping rectangles and calculating the total area. It also requires understanding of list comprehension and assertions in Python.",
        "description": "Find the solution: xy_sides (a list of lists of integers representing coordinates and side lengths) that should satisfy the constraints of non-overlapping squares within a larger square, with each square having a unique side length, and the sum of the squares' areas equaling the area of the larger square.",
        "quality": 1,
        "fitness": 0.45050719380378723
    },
    {
        "program_str": "def f(n: int, lace='brrrbrrbrbbbbbrrbbrr') -> bool:\n    sub = lace[n:n + len(lace) // 2]\n    return n >= 0 and lace.count('r') == 2 * sub.count('r') and (lace.count('b') == 2 * sub.count('b'))\ndef g(lace = 'brrrbrrbrbbbbbrrbbrr'):\n    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: an integer `n` that should be used to satisfy the conditions specified in the function `f` with respect to the string `lace`.",
        "quality": 1,
        "fitness": 0.5996663570404053
    },
    {
        "program_str": "def f(n: int) -> bool:\n    s = str(n * n)\n    for i in '0123456789':\n        assert s.count(i) == 1\n    return True\ndef g():\n    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, mathematical operations, conditional logic, and sorting and ordering.",
        "description": "Find the solution: n (integer) that should be a unique number such that when n is squared, the resulting number contains each digit from 0 to 9 exactly once.",
        "quality": 1,
        "fitness": 0.5766300559043884
    },
    {
        "program_str": "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 2 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1\"\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation, mathematical operations, conditional logic, and set operations.",
        "description": "Find the solution: s (a string) that should contain only the characters '1', '8', '-', '+', '*', '/' and satisfy the conditions: having exactly two '8's, one '1', and evaluating to 63 when using the eval function.",
        "quality": 1,
        "fitness": 0.5996864438056946
    },
    {
        "program_str": "def f(s: str) -> bool:\n    return set(s) <= set('18-+*/') and s.count('8') == 3 and (s.count('1') == 1) and (eval(s) == 63)\ndef g():\n    return \"8*8-1**8\"\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, mathematical operations, conditional logic, and evaluation of an expression.",
        "description": "Find the solution: s (a string) that should contain only the characters '1', '8', '-', '+', '*', '/' and satisfy the conditions: exactly 3 occurrences of '8', exactly 1 occurrence of '1', and evaluating s should result in 63.",
        "quality": 1,
        "fitness": 0.6001356840133667
    },
    {
        "program_str": "from typing import List \ndef f(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]) -> bool:\n    state = init.copy()\n    for [i, j] in moves:\n        assert min(i, j) >= 0, 'Indices must be non-negative'\n        assert i != j, 'Cannot pour from same state to itself'\n        n = min(capacities[j], state[i] + state[j])\n        (state[i], state[j]) = (state[i] + state[j] - n, n)\n    return state == goal\ndef g(capacities = [724, 43, 611], init = [72, 2, 269], goal = [56, 0, 287]):\n    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Backtracking, Array Indexing, and Algorithm Optimization.",
        "description": "Find the solution: moves (represented as a list of lists of integers) that should transfer liquid between containers to reach the specified goal state from the initial state, respecting the given capacities and constraints.",
        "quality": 1,
        "fitness": 0.5188498497009277
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int], words=['GREEN', 'ORANGE', 'COLORS']) -> bool:\n    assert len(li) == len(words) and all((i > 0 and len(str(i)) == len(w) for (i, w) in zip(li, words)))\n    assert len({c for w in words for c in w}) == len({(d, c) for (i, w) in zip(li, words) for (d, c) in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]\ndef g(words = ['GREEN', 'ORANGE', 'COLORS']):\n    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Permutations and Combinations",
        "description": "Find the solution: a list of integers `li` that should satisfy the constraints of having the same length as the list of words, each integer in `li` should be greater than 0 and have the same number of digits as the corresponding word's length, and the sum of all integers in `li` except the last one should equal the last integer in `li`.",
        "quality": 1,
        "fitness": 0.4978589713573456
    },
    {
        "program_str": "def f(s: str, word='pawuzorythalirinasubyg', max_len=12) -> bool:\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and (word[-1] == s[-1])\ndef g(word = 'pawuzorythalirinasubyg', max_len = 12):\n    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\"\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: s (a string) that should match the given word with specific constraints on its length and characters at the beginning and end.",
        "quality": 1,
        "fitness": 0.5706677436828613
    },
    {
        "program_str": "from typing import List \ndef f(corners: List[List[int]], m=74, n=1, a=2, target=38) -> bool:\n    covered = {(i + x, j + y) for (i, j) in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, 'Double coverage'\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})\ndef g(m = 74, n = 1, a = 2, target = 38):\n    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves grid manipulation and checking coverage, which falls under Geometry and Coordinate Manipulation and Set Operations.",
        "description": "Find the solution: corners (represented as a list of lists of integers) that should cover a specific area defined by the arguments m, n, a, and target, ensuring no double coverage and meeting the constraints specified in the function f.",
        "quality": 1,
        "fitness": 0.461784690618515
    },
    {
        "program_str": "from typing import List \ndef f(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]) -> bool:\n    return len(lb) == len(trips) and all((b is True if sum(s) >= 2 else b is False for (b, s) in zip(lb, trips)))\ndef g(trips = [[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return [sum(s) >= 2 for s in trips]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic and list manipulation to check if the number of True values in a list of lists is greater than or equal to 2.",
        "description": "Find the solution: a list of boolean values that should satisfy the condition that for each sublist in `trips`, if the sum of its elements is greater than or equal to 2, the corresponding boolean value in the solution list should be True, otherwise False.",
        "quality": 1,
        "fitness": 0.430566668510437
    },
    {
        "program_str": "def f(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6) -> bool:\n    assert all((scores[i] >= scores[i + 1] for i in range(len(scores) - 1))), 'Hint: scores are non-decreasing'\n    return all((s >= scores[k] and s > 0 for s in scores[:n])) and all((s < scores[k] or s <= 0 for s in scores[n:]))\ndef g(scores = [100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k = 6):\n    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, Array Indexing",
        "description": "Find the solution: `n (int)` that should be an index dividing the `scores` list into two parts such that the first part contains only positive values greater than or equal to the value at index `k`, and the second part contains non-positive values less than the value at index `k`.",
        "quality": 1,
        "fitness": 0.4671681225299835
    },
    {
        "program_str": "def f(t: str, s='kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL') -> bool:\n    i = 0\n    for c in s.lower():\n        if c in 'aeiouy':\n            continue\n        assert t[i] == '.', f'expecting `.` at position {i}'\n        i += 1\n        assert t[i] == c, f'expecting `{c}`'\n        i += 1\n    return i == len(t)\ndef g(s = 'kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL'):\n    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Conditional Logic",
        "description": "Find the solution: a string `t` that should consist of alternating '.' and consonants from the given string `s`, while skipping vowels and 'y'.",
        "quality": 1,
        "fitness": 0.567368745803833
    },
    {
        "program_str": "from typing import List \ndef f(squares: List[List[int]], m=35, n=46, target=1610) -> bool:\n    covered = []\n    for (i1, j1, i2, j2) in squares:\n        assert 0 <= i1 <= i2 < m and 0 <= j1 <= j2 < n and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target\ndef g(m = 35, n = 46, target = 1610):\n    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Array Indexing, Conditional Logic, and Set Operations.",
        "description": "Find the solution: squares (2x2 grids) that should cover unique cells in a larger grid of size m x n, with the goal of covering a specific number of cells (target) without overlapping.",
        "quality": 1,
        "fitness": 0.46813660860061646
    },
    {
        "program_str": "def f(n: int, s='tExTYtOHahekomArof', t='TExTYTohaHeKomryGUSeteXTUrYgir') -> bool:\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False\ndef g(s = 'tExTYtOHahekomArof', t = 'TExTYTohaHeKomryGUSeteXTUrYgir'):\n    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Conditional Logic",
        "description": "Find the solution: an integer `n` that should determine the relationship between two strings `s` and `t` based on the comparison rules specified in the function `f`.",
        "quality": 1,
        "fitness": 0.531328022480011
    },
    {
        "program_str": "def f(s: str, word='silon') -> bool:\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        elif s[i] != word[i]:\n            return False\n    return True\ndef g(word = 'silon'):\n    return word[0].upper() + word[1:]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "description": "Find the solution: s (a string) that should start with the uppercase version of the first character of the word 'silon' and match the rest of the characters in 'silon' in order.",
        "quality": 1,
        "fitness": 0.5461419820785522
    },
    {
        "program_str": "def f(t: str, s='c', target=1) -> bool:\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all((t[i] != t[i + 1] for i in range(len(t) - 1)))\ndef g(s = 'c', target = 1):\n    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: a string `t` that should have a length greater than or equal to the specified target value and all characters in the string should be different from their adjacent characters.",
        "quality": 1,
        "fitness": 0.48040851950645447
    },
    {
        "program_str": "from typing import List \ndef f(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]) -> bool:\n    return all((sum((vec[i] for vec in nums)) + delta[i] == 0 for i in range(3)))\ndef g(nums = [[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return [-sum(vec[i] for vec in nums) for i in range(3)]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and list manipulation.",
        "description": "Find the solution: a list of integers `delta` that should adjust the sums of columns in the given list of lists `nums` to be equal to zero for each column.",
        "quality": 1,
        "fitness": 0.43350106477737427
    },
    {
        "program_str": "def f(n: int, a=14, b=50, c=47) -> bool:\n    return n + a == sum([b * i for i in range(c)])\ndef g(a = 14, b = 50, c = 47):\n    return -a + sum([b * i for i in range(c)])\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and array indexing.",
        "description": "Find the solution: n (integer) that should satisfy the equation n + 14 == sum([50 * i for i in range(47)]) to solve the puzzle.",
        "quality": 1,
        "fitness": 0.5948048830032349
    },
    {
        "program_str": "def f(n: int, v=609909721, w=872375011) -> bool:\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w\ndef g(v = 609909721, w = 872375011):\n    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and iterative algorithms.",
        "description": "Find the solution: n (integer) that should determine the number of iterations to ensure v is always less than or equal to w after each iteration, where v and w are initialized values that change based on the iteration.",
        "quality": 1,
        "fitness": 0.5684442520141602
    },
    {
        "program_str": "def f(res: int, m=22262059435814874058, n=6) -> bool:\n    for i in range(n):\n        m = m - 1 if m % 10 else m // 10\n    return res == m\ndef g(m = 22262059435814874058, n = 6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations, Conditional Logic, and Recursion.",
        "description": "Find the solution: res (an integer) that should match the value of m after a series of operations based on the value of n.",
        "quality": 1,
        "fitness": 0.5645503997802734
    },
    {
        "program_str": "def f(n: int, pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]) -> bool:\n    assert sum((p - m for (p, m) in pairs)) == 0, 'oo'\n    tot = 0\n    success = False\n    for (p, m) in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success\ndef g(pairs = [[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):\n    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Array Indexing, Conditional Logic, and Mathematical Operations.",
        "description": "Find the solution: n (an integer) that should satisfy the constraint of summing up pairs of numbers to equal n, as defined in the pairs list, in order to solve the puzzle.",
        "quality": 1,
        "fitness": 0.4903034269809723
    },
    {
        "program_str": "def f(s_case: str, s='rAC') -> bool:\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())\ndef g(s = 'rAC'):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation and Conditional Logic are used in this puzzle.",
        "description": "Find the solution: s_case (string) that should match the case of the input string 's' based on whether the majority of characters are uppercase or lowercase.",
        "quality": 1,
        "fitness": 0.5538027286529541
    },
    {
        "program_str": "from typing import List \ndef f(inds: List[int], string='gteliikeenGgqIHent') -> bool:\n    return inds == sorted(inds) and ''.join((string[i] for i in inds)) == 'intelligent'\ndef g(string = 'gteliikeenGgqIHent'):\n    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and indexing in Python.",
        "description": "Find the solution: a list of indices that should be sorted and used to form the word 'intelligent' by selecting characters from the given string.",
        "quality": 1,
        "fitness": 0.5510247349739075
    },
    {
        "program_str": "def f(d: int, n=707) -> bool:\n    return d > n and all((i in '47' for i in str(str(d).count('4') + str(d).count('7'))))\ndef g(n = 707):\n    return int(\"4444\" + \"0\" * (len(str(n)) - 3))\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "description": "Find the solution: an integer `d` that should be greater than 707 and have the property that the count of '4's and '7's in its digits, when concatenated, only contain '4' and '7'.",
        "quality": 1,
        "fitness": 0.5353075861930847
    },
    {
        "program_str": "def f(s: str, target='rechawewivetextovy', reverse=True) -> bool:\n    return (s[::-1] == target) == reverse\ndef g(target = 'rechawewivetextovy', reverse = True):\n    return target[::-1] if reverse else target + \"x\"\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: s (a string) that should be equal to the target string when reversed, based on the reverse flag, in order to satisfy the puzzle constraints.",
        "quality": 1,
        "fitness": 0.5737883448600769
    },
    {
        "program_str": "def f(s: str, a=4763, d=8408) -> bool:\n    return s.count('a') == a and s.count('d') == d and (len(s) == a + d)\ndef g(a = 4763, d = 8408):\n    return \"a\" * a + \"d\" * d\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: s (a string) that should have the correct count of 'a' and 'd' characters as specified by the arguments a and d, and the length of the string should be equal to the sum of a and d.",
        "quality": 1,
        "fitness": 0.5988089442253113
    },
    {
        "program_str": "from typing import List \ndef f(nums: List[int], a=136, b=176, count=34) -> bool:\n    assert all((len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums))\n    return len(set(nums)) >= count\ndef g(a = 136, b = 176, count = 34):\n    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves checking for unique digits in numbers and counting the unique numbers within a range. It also uses list comprehension and set operations in Python.",
        "description": "Find the solution: nums (a list of integers) that should contain unique integers within the range of a and b, with each integer having distinct digits, and the number of unique integers should be greater than or equal to the count specified.",
        "quality": 1,
        "fitness": 0.506390392780304
    },
    {
        "program_str": "def f(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17) -> bool:\n    return tot == sum((1 if i < thresh else 2 for i in nums))\ndef g(nums = [2, 8, 25, 18, 99, 11, 17, 16], thresh = 17):\n    return sum(1 if i < thresh else 2 for i in nums)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to compare the sum of elements in a list to a given threshold.",
        "description": "Find the solution: `tot` (an integer) that should equal the sum of 1s and 2s based on the condition that if an element in `nums` is less than `thresh`, it contributes 1 to the sum, otherwise it contributes 2.",
        "quality": 1,
        "fitness": 0.5413394570350647
    },
    {
        "program_str": "from typing import List \ndef f(ans: List[List[int]], target=17) -> bool:\n    for i in range(len(ans)):\n        (a, b) = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0\ndef g(target = 17):\n    return [[0, 2]] * target\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic and list manipulation to achieve a specific target value.",
        "description": "Find the solution: ans (a list of lists of integers) that should contain intervals satisfying the condition that the difference between the end and start of each interval is at least 2, in order to reach a target count of intervals.",
        "quality": 1,
        "fitness": 0.5766543745994568
    },
    {
        "program_str": "def f(s: str, n=2) -> bool:\n    return int(str(5 ** n)[:-2] + s) == 5 ** n\ndef g(n = 2):\n    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Mathematical Operations",
        "description": "Find the solution: s (a string) that, when concatenated with a specific number, results in a number that is equal to 5 raised to the power of n.",
        "quality": 1,
        "fitness": 0.5844224095344543
    },
    {
        "program_str": "from typing import List \ndef f(states: List[str], start='424', combo='778', target_len=12) -> bool:\n    assert all((len(s) == len(start) for s in states)) and all((c in '0123456789' for s in states for c in s))\n    for (a, b) in zip([start] + states, states + [combo]):\n        assert sum((i != j for (i, j) in zip(a, b))) == 1\n        assert all((abs(int(i) - int(j)) in {0, 1, 9} for (i, j) in zip(a, b)))\n    return len(states) <= target_len\ndef g(start = '424', combo = '778', target_len = 12):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation, conditional logic, and array indexing.",
        "description": "Find the solution: states (as a list of strings) that should form a sequence where each state differs from the previous one by changing only one digit, and the absolute difference between the corresponding digits in each state is either 0, 1, or 9. The goal is to find a sequence of states that satisfies these constraints within a specified target length.",
        "quality": 1,
        "fitness": 0.4632425904273987
    },
    {
        "program_str": "from typing import List \ndef f(states: List[str], start='4', combo='3', target_len=0) -> bool:\n    return all((sum(((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start)))) == 1 for (a, b) in zip([start] + states, states[:target_len] + [combo])))\ndef g(start = '4', combo = '3', target_len = 0):\n    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic, List Operations",
        "description": "Find the solution: states (as a list of strings) that should form a sequence where each state differs from the previous one by changing only one digit at a time, with the goal of reaching the target state specified by the 'combo' argument.",
        "quality": 1,
        "fitness": 0.4585738480091095
    },
    {
        "program_str": "def f(s: str, perm='qwertyuiopasdfghjklzxcvbnm', target='mujychenyzo') -> bool:\n    return ''.join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c for c in s)) == target\ndef g(perm = 'qwertyuiopasdfghjklzxcvbnm', target = 'mujychenyzo'):\n    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Permutations and Combinations",
        "description": "Find the solution: s (a string) that should transform each character in the input string s according to the given permutation rule and match the target string.",
        "quality": 1,
        "fitness": 0.5568305850028992
    },
    {
        "program_str": "from typing import List \ndef f(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4) -> bool:\n    (a, b) = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True\ndef g(items = [5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length = 4):\n    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, counting elements, and assertion checks.",
        "description": "Find the solution: lists of integers that should have a specific length, unique elements in the first list, and one repeated element in the second list, while satisfying the constraints on the frequency of elements compared to a predefined list of items.",
        "quality": 1,
        "fitness": 0.47583287954330444
    },
    {
        "program_str": "from typing import List \ndef f(seq: List[int], n=10000, length=5017) -> bool:\n    return all((i in [1, 2] for i in seq)) and sum(seq) == n and (len(seq) == length)\ndef g(n = 10000, length = 5017):\n    return [2] * (n - length) + [1] * (2 * length - n)\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves list manipulation, conditional logic, and mathematical operations.",
        "description": "Find the solution: a list of integers `seq` that should contain only elements 1 or 2, have a sum equal to 10000, and a length of 5017 in order to solve the puzzle.",
        "quality": 1,
        "fitness": 0.5288456678390503
    },
    {
        "program_str": "def f(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper\ndef g(k = 2, upper = -172, seq = [79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Brute Force Search and Mathematical Operations.",
        "description": "Find the solution: start (integer) that should satisfy the condition of summing k consecutive elements in the sequence seq to be less than or equal to the upper bound, starting from the given index start.",
        "quality": 1,
        "fitness": 0.48120710253715515
    },
    {
        "program_str": "def f(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]) -> bool:\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower\ndef g(k = 3, lower = 150, seq = [3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and finding the maximum sum subarray within a list.",
        "description": "Find the solution: start (integer) that should select a starting index in a sequence such that the sum of k consecutive elements starting from that index is greater than or equal to a specified lower bound.",
        "quality": 1,
        "fitness": 0.479232519865036
    },
    {
        "program_str": "def f(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]) -> bool:\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower\ndef g(k = 10, lower = -8326797433194240, seq = [49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):\n    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations, array indexing, and algorithm optimization.",
        "description": "Find the solution: start (integer) that should multiply a sequence of numbers within a specified range to produce a product greater than or equal to a given lower bound.",
        "quality": 1,
        "fitness": 0.46545732021331787
    },
    {
        "program_str": "from typing import List \ndef f(nums: List[int], tot=5359, n=11) -> bool:\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all((i >= i % 2 > 0 for i in nums))\ndef g(tot = 5359, n = 11):\n    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, list operations, and conditional logic.",
        "description": "Find the solution: nums (a list of integers) that should have unique elements, sum up to 5359, have a length of 11, and all elements satisfy the condition i >= i % 2 > 0.",
        "quality": 1,
        "fitness": 0.5068463683128357
    },
    {
        "program_str": "from typing import List \ndef f(rotations: List[int], target='wonderful', upper=69) -> bool:\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    assert len(rotations) == len(target)\n    for (r, c) in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return sum((abs(r) for r in rotations)) <= upper\ndef g(target = 'wonderful', upper = 69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "String manipulation, List operations, Looping, Assertions",
        "description": "Find the solution: rotations (list of integers) that should rearrange the alphabet string to match the target word, while ensuring the total absolute value of rotations is within the specified upper limit.",
        "quality": 1,
        "fitness": 0.5022282600402832
    },
    {
        "program_str": "from typing import List \ndef f(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18) -> bool:\n    return sum(bills) == n and all((b in denominations for b in bills)) and (len(bills) <= max_len)\ndef g(denominations = [1, 44, 69], n = 727, max_len = 18):\n    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves dynamic programming to solve a problem related to denominations and a target amount. The solution uses a dynamic programming approach to optimize the solution. It also involves list manipulation and sorting. The puzzle and solution both relate to topics such as Dynamic Programming, Set Operations, Sorting and Ordering.",
        "description": "Find the solution: list of bills (integers) that should add up to a specific amount `n`, consist only of denominations [1, 44, 69], and have a maximum length of 18 bills.",
        "quality": 1,
        "fitness": 0.42921358346939087
    },
    {
        "program_str": "from typing import List \ndef f(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13) -> bool:\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and (len(sides) <= max_dim)\ndef g(options = [2, 512, 1024], n = 340282366920938463463374607431768211456, max_dim = 13):\n    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, set operations, list manipulation, and algorithm optimization.",
        "description": "Find the solution: sides (list of integers) that should multiply to a specific number, be within a set of options, and have a maximum dimension constraint.",
        "quality": 1,
        "fitness": 0.39171740412712097
    },
    {
        "program_str": "def f(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]) -> bool:\n    (a, b, c) = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-06\ndef g(coeffs = [0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and mathematical optimization.",
        "description": "Find the solution: x (float) that should satisfy the quadratic equation constraint defined by the coefficients a, b, and c in the function f(x) to be within a certain tolerance.",
        "quality": 1,
        "fitness": 0.5679043531417847
    },
    {
        "program_str": "from typing import List \ndef f(roots: List[float], coeffs=[9.155105839032705, -0.9467446341738642]) -> bool:\n    (b, c) = coeffs\n    (r1, r2) = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-06\ndef g(coeffs = [9.155105839032705, -0.9467446341738642]):\n    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves solving a quadratic equation and checking the roots to satisfy a condition.",
        "description": "Find the solution: roots (float) that should satisfy the constraints of the puzzle with respect to the coefficients b and c, such that the absolute sum of the roots with b and the absolute difference of the roots multiplied equals c are within a small threshold.",
        "quality": 1,
        "fitness": 0.5171090364456177
    },
    {
        "program_str": "def f(x: str, s=86120) -> bool:\n    return s == sum([int(d) for d in x])\ndef g(s = 86120):\n    return int(s / 9) * '9' + str(s % 9)\nassert f(g()) == True",
        "emb": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Mathematical Operations",
        "description": "Find the solution: x (a string) that should contain digits whose sum equals the value of s (86120) to solve the puzzle.",
        "quality": 1,
        "fitness": 0.5742297172546387
    },
    {
        "program_str": "def f(z: float, v=9, d=0.0001) -> bool:\n    return int(z * 1 / d % 10) == v\ndef g(v = 9, d = 0.0001):\n    return v * d\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if a certain condition is met.",
        "description": "Find the solution: z (float) that should satisfy the condition int(z * 1 / d % 10) == v, where v is an integer and d is a small float value.",
        "quality": 1,
        "fitness": 0.5904203653335571
    },
    {
        "program_str": "from typing import List \ndef f(x: List[int], a=43536, s=3795, e=417606) -> bool:\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])\ndef g(a = 43536, s = 3795, e = 417606):\n    return list(range(a, e + 1, s))\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves generating a list of numbers based on a given range and step size, and then checking if certain conditions are met within that list.",
        "description": "Find the solution: a list of integers that should start with a specific value, end within a certain range, have consecutive elements differing by a fixed step, and satisfy all the constraints defined by the arguments a, s, and e in the function f.",
        "quality": 1,
        "fitness": 0.527237594127655
    },
    {
        "program_str": "from typing import List \ndef f(e: List[int], a=2, b=-1, c=1, d=2021) -> bool:\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** (-5)\ndef g(a = 2, b = -1, c = 1, d = 2021):\n    return [d - b, a - c]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if a certain condition is met.",
        "description": "Find the solution: a list of two integers e, that should satisfy the equation abs(a * (e[0] / e[1]) + b - c * (e[0] / e[1]) - d) < 10 ** (-5) with given values of a, b, c, and d.",
        "quality": 1,
        "fitness": 0.5499022603034973
    },
    {
        "program_str": "def f(x: int, a=22, b=-84904666) -> bool:\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b\ndef g(a = 22, b = -84904666):\n    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves conditional logic and mathematical operations.",
        "description": "Find the solution: an integer `x` that should satisfy the condition `x - a == b` if `x > 0` or `x + a == b` if `x <= 0`, where `a` is greater than 50 and `b` is a specific negative integer.",
        "quality": 1,
        "fitness": 0.5624241828918457
    },
    {
        "program_str": "def f(x: int, a=-3, b=71965664) -> bool:\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b\ndef g(a = -3, b = 71965664):\n    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves topics such as Conditional Logic, Mathematical Operations, and Function Definition.",
        "description": "Find the solution: an integer `x` that should satisfy the conditions based on the values of `a` and `b` in the function `f`, such that when `g()` is called, `f(g())` returns True.",
        "quality": 1,
        "fitness": 0.5593512654304504
    },
    {
        "program_str": "from typing import List \ndef f(x: List[int], n=9909, s=88140438) -> bool:\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])\ndef g(n = 9909, s = 88140438):\n    x = [1] * n\n    x[0] = s - n + 1\n    return x\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves creating a list of integers with specific properties such as length, sum, and all elements being positive. The solution generates the list based on the given length and sum constraints.",
        "description": "Find the solution: a list of integers that should have a length of 9909, sum up to 88140438, and contain only positive values.",
        "quality": 1,
        "fitness": 0.5084348320960999
    },
    {
        "program_str": "from typing import List \ndef f(x: List[int], n=225, s=38417364) -> bool:\n    return len(x) == n and sum(x) == s and (len(set(x)) == n)\ndef g(n = 225, s = 38417364):\n    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, conditional logic, and brute force search.",
        "description": "Find the solution: a list of integers that should contain exactly 225 elements, with a sum of 38417364, and all elements are unique within the list.",
        "quality": 1,
        "fitness": 0.47742998600006104
    },
    {
        "program_str": "def f(x: str, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n=16) -> bool:\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])\ndef g(s = ['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n = 16):\n    return ''.join([s[i] for i in range(n)])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "String Manipulation, Array Indexing",
        "description": "Find the solution: x (a string) that should match a predefined sequence of characters s with a length of n.",
        "quality": 1,
        "fitness": 0.4886992573738098
    },
    {
        "program_str": "from typing import List \ndef f(x: List[int], t=44475424, a=93, e=8496, s=6) -> bool:\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all([x[i] != 0 for i in range(a, e, s)])\ndef g(t = 44475424, a = 93, e = 8496, s = 6):\n    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves array indexing, conditional logic, and mathematical operations.",
        "description": "Find the solution: a list of integers that should satisfy specific constraints defined by the function f, such as the sum of elements within a range, no zero elements, and unique non-zero elements.",
        "quality": 1,
        "fitness": 0.45419585704803467
    },
    {
        "program_str": "from typing import List \ndef f(x: List[int], t=364928431, n=1088) -> bool:\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n\ndef g(t = 364928431, n = 1088):\n    return [1] * n + [t]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves sorting a list of integers and checking a condition based on the sum of the sorted list. The solution creates a list of 1s with a specific length and appends a target value at the end to satisfy the condition in the puzzle.",
        "description": "Find the solution: a list of integers that should have all positive values and when sorted, the cumulative sum does not exceed the threshold `t`, and the number of elements in the list should be equal to `n`.",
        "quality": 1,
        "fitness": 0.511752188205719
    },
    {
        "program_str": "def f(s: str, s1='t', s2='qu', count1=86, count2=83) -> bool:\n    return s.count(s1) == count1 and s.count(s2) == count2 and (s[:10] == s[-10:])\ndef g(s1 = 't', s2 = 'qu', count1 = 86, count2 = 83):\n    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation, Conditional Logic",
        "description": "Find the solution: s (a string) that should have a specific count of characters 't' and 'qu', and the first 10 characters should be the same as the last 10 characters.",
        "quality": 1,
        "fitness": 0.49417856335639954
    },
    {
        "program_str": "def f(s: str, substrings=['te', 'wusyc']) -> bool:\n    return all((sub in s[i::len(substrings)] for (i, sub) in enumerate(substrings)))\ndef g(substrings = ['te', 'wusyc']):\n    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "String Manipulation, Array Indexing",
        "description": "Find the solution: s (a string) that should contain all the substrings in the list 'substrings' in a specific order and spacing within s.",
        "quality": 1,
        "fitness": 0.5400847792625427
    },
    {
        "program_str": "def f(s: str, substrings=['foo', 'bar', 'baz']) -> bool:\n    return all((sub in s and sub[::-1] in s for sub in substrings))\ndef g(substrings = ['foo', 'bar', 'baz']):\n    return \"\".join(substrings + [s[::-1] for s in substrings])\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: s (a string) that should contain all substrings in the list 'substrings' and their reversed forms in order to solve the puzzle.",
        "quality": 1,
        "fitness": 0.5816898941993713
    },
    {
        "program_str": "def f(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']) -> bool:\n    return s in strings and sum((t > s for t in strings)) == 1\ndef g(strings = ['cat', 'dog', 'bird', 'fly', 'moose']):\n    return sorted(strings)[-2]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and list operations.",
        "description": "Find the solution: s (a string) that should be one of the strings in the list and should have exactly one string greater than it in lexicographical order.",
        "quality": 1,
        "fitness": 0.5815964341163635
    },
    {
        "program_str": "def f(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']) -> bool:\n    return s[::-1] in strings and sum((t < s[::-1] for t in strings)) == 1\ndef g(strings = ['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):\n    return sorted(strings)[1][::-1]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and sorting and ordering topics.",
        "description": "Find the solution: s (a string) that should be the reverse of one of the strings in the list and be the only string that comes before its reverse in lexicographical order among the list of strings.",
        "quality": 1,
        "fitness": 0.4970959722995758
    },
    {
        "program_str": "def f(s: str, target='foobarbazwow', length=6) -> bool:\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s\ndef g(target = 'foobarbazwow', length = 6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: a string `s` that should match the substring of length `length` in the middle of the target string `target`.",
        "quality": 1,
        "fitness": 0.5601173639297485
    },
    {
        "program_str": "def f(substring: str, string='cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf', count=3) -> bool:\n    return string.count(substring) == count\ndef g(string = 'cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf', count = 3):\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Brute Force Search",
        "description": "Find the solution: substring (str) that should appear exactly 3 times in the given string, 'cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf'.",
        "quality": 1,
        "fitness": 0.5566097497940063
    },
    {
        "program_str": "def f(t: str, s='))())l') -> bool:\n    for i in range(len(t) + 1):\n        depth = t[:i].count('(') - t[:i].count(')')\n        assert depth >= 0\n    return depth == 0 and s in t\ndef g(s = '))())l'):\n    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: t (string) that should have balanced parentheses and contain the substring '))())l'.",
        "quality": 1,
        "fitness": 0.5221686363220215
    },
    {
        "program_str": "from typing import List \ndef f(squares: List[List[int]], m=9, n=6) -> bool:\n    k = min(m, n)\n    assert all((i in range(m) and j in range(n) for (i, j) in squares)) and len(squares) == k\n    return 4 * k == len({t for (i, j) in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})\ndef g(m = 9, n = 6):\n    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves a combination of Brute Force Search and Set Operations to solve a problem related to squares in a grid. The solution uses permutations to iterate through possible square placements and checks if certain conditions are met to form a valid square configuration.",
        "description": "Find the solution: squares (2D points) that should cover a grid of size m x n such that each square covers a unique row, column, southeast diagonal, and northeast diagonal.",
        "quality": 1,
        "fitness": 0.5046736001968384
    },
    {
        "program_str": "from typing import List \ndef f(tour: List[List[int]], m=7, n=8) -> bool:\n    assert all(({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for ([i1, j1], [i2, j2]) in zip(tour, tour[1:]))), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]\ndef g(m = 7, n = 8):\n    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves backtracking and graph theory (paths, edges, vertices). The solution uses algorithm optimization and randomization.",
        "description": "Find the solution: tour (a list of coordinates) that should visit all cells in an m x n grid with legal moves of exactly 1 unit horizontally and 2 units vertically between adjacent cells.",
        "quality": 1,
        "fitness": 0.4128248989582062
    },
    {
        "program_str": "from typing import List \ndef f(position: List[List[int]], target=[[-1, -4], [-1, -3], [0, -5], [0, -4], [1, -3]]) -> bool:\n    live = {x + y * 1j for (x, y) in position}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum((z + d in live for d in deltas)) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for (x, y) in target}\ndef g(target = [[-1, -4], [-1, -3], [0, -5], [0, -4], [1, -3]]):\n    # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics related to optimization algorithms, set operations, and probability.",
        "description": "Find the solution: a list of positions (represented as lists of integers) that should determine the next step in a game of life simulation, following specific rules based on the positions of live cells and their neighbors.",
        "quality": 1,
        "fitness": 0.4622308909893036
    },
    {
        "program_str": "from typing import List \ndef f(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]) -> bool:\n\n    def bot_move() -> bool:\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])\n        state[i_largest] -= max(vals[0] - vals[1], 1)\n    state = initial_state[:]\n    for (i, n) in moves:\n        assert 0 < n <= state[i], 'Illegal move'\n        state[i] -= n\n        if set(state) == {0}:\n            return True\n        assert any(state), 'You lost!'\n        bot_move()\ndef g(initial_state = [3, 3, 2, 2, 3, 8]):\n\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as Backtracking, Recursion, Array Indexing, and Algorithm Optimization.",
        "description": "Find the solution: moves (List of List[int]) that should deplete all the elements in the initial state list to zero by subtracting valid amounts from each element, following the rules of the game.",
        "quality": 1,
        "fitness": 0.5408649444580078
    },
    {
        "program_str": "from typing import List \ndef f(probs: List[float]) -> bool:\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-06\n    return max((probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3))) < 1e-06\ndef g():\n    return [1 / 3] * 3\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic to check if a certain condition is met. It also requires understanding of list manipulation and indexing.",
        "description": "Find the solution: a list of probabilities that should sum up to 1 and have a maximum difference of less than 1e-06 between any two consecutive probabilities in the list.",
        "quality": 1,
        "fitness": 0.5412155389785767
    },
    {
        "program_str": "from typing import List \ndef f(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]) -> bool:\n    (a, b, c) = tri\n    return [a, b] in edges and [b, c] in edges and ([c, a] in edges) and (a != b != c != a)\ndef g(edges = [[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves graph theory, specifically paths and edges.",
        "description": "Find the solution: tri (a tuple of three integers) that should form a triangle with edges defined in the `edges` list, satisfying the conditions that each edge is present in the list, and the vertices are distinct.",
        "quality": 1,
        "fitness": 0.4658306837081909
    },
    {
        "program_str": "from typing import List \ndef f(path: List[int], weights=[{1: 996, 2: 237, 4: 264}, {4: 329, 5: 12, 2: 542, 0: 419}, {2: 170, 6: 339, 5: 211}, {1: 714, 5: 885, 3: 640}, {5: 652, 4: 3, 3: 26, 6: 74}, {0: 647, 5: 346}, {2: 297, 6: 358, 3: 636, 0: 722, 4: 942}], bound=996) -> bool:\n    return path[0] == 0 and path[-1] == 1 and (sum((weights[a][b] for (a, b) in zip(path, path[1:]))) <= bound)\ndef g(weights = [{1: 996, 2: 237, 4: 264}, {4: 329, 5: 12, 2: 542, 0: 419}, {2: 170, 6: 339, 5: 211}, {1: 714, 5: 885, 3: 640}, {5: 652, 4: 3, 3: 26, 6: 74}, {0: 647, 5: 346}, {2: 297, 6: 358, 3: 636, 0: 722, 4: 942}], bound = 996):\n    # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves graph theory (paths, edges, vertices) and algorithm optimization.",
        "description": "Find the solution: path (sequence of nodes) that should connect node 0 to node 1 while satisfying the weight constraints defined by the weights dictionary and not exceeding the specified bound.",
        "quality": 1,
        "fitness": 0.4549265503883362
    },
    {
        "program_str": "from typing import List \ndef f(path: List[int], edges=[[0, 0]]) -> bool:\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max((max(edge) for edge in edges))\n    return True\ndef g(edges = [[0, 0]]):\n    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves graph theory, specifically paths and edges.",
        "description": "Find the solution: path (list of integers) that should traverse all edges specified in the 'edges' list, starting from node 0 and ending at the maximum node value in the edges list.",
        "quality": 1,
        "fitness": 0.5279962420463562
    },
    {
        "program_str": "from typing import List \ndef f(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]) -> bool:\n    assert path[0] == 0 and path[-1] == max((max(e) for e in edges))\n    assert all([[a, b] in edges for (a, b) in zip(path, path[1:])])\n    return len(path) % 2 == 0\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves graph theory, specifically paths and edges. It also involves conditional logic and list manipulation.",
        "description": "Find the solution: path (list of integers) that should traverse all edges in the given graph starting from node 0 and ending at the maximum node number, such that the path length is even.",
        "quality": 1,
        "fitness": 0.4918823540210724
    },
    {
        "program_str": "from typing import List \ndef f(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]) -> bool:\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for (a, b) in zip(p, p[1:])])\ndef g(edges = [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves graph theory and backtracking to find a path from node 0 to node 1 in a given graph. It also includes list manipulation and conditional logic to check if the path satisfies certain conditions.",
        "description": "Find the solution: p (a list of integers) that should start with 0, end with 1, have an odd length, and all consecutive pairs of elements should be present in the given edges list.",
        "quality": 1,
        "fitness": 0.46019452810287476
    },
    {
        "program_str": "from typing import List \ndef f(bi: List[int], g1=[[0, 1], [0, 7], [1, 1], [2, 0], [2, 3], [2, 5], [2, 6], [3, 0], [3, 1], [3, 2], [3, 5], [3, 6], [3, 7], [4, 3], [4, 5], [4, 6], [5, 0], [5, 2], [5, 3], [6, 0], [6, 5], [6, 7], [7, 0], [7, 4], [7, 6]], g2=[[0, 7], [7, 1], [0, 2], [3, 1], [2, 0], [7, 0], [0, 6], [4, 7], [2, 7], [7, 6], [1, 6], [3, 6], [6, 5], [1, 3], [7, 3], [4, 0], [1, 0], [3, 4], [2, 1], [2, 6], [7, 2], [6, 3], [7, 5], [4, 1], [5, 5]]) -> bool:\n    return len(bi) == len(set(bi)) and {(i, j) for (i, j) in g1} == {(bi[i], bi[j]) for (i, j) in g2}\ndef g(g1 = [[0, 1], [0, 7], [1, 1], [2, 0], [2, 3], [2, 5], [2, 6], [3, 0], [3, 1], [3, 2], [3, 5], [3, 6], [3, 7], [4, 3], [4, 5], [4, 6], [5, 0], [5, 2], [5, 3], [6, 0], [6, 5], [6, 7], [7, 0], [7, 4], [7, 6]], g2 = [[0, 7], [7, 1], [0, 2], [3, 1], [2, 0], [7, 0], [0, 6], [4, 7], [2, 7], [7, 6], [1, 6], [3, 6], [6, 5], [1, 3], [7, 3], [4, 0], [1, 0], [3, 4], [2, 1], [2, 6], [7, 2], [6, 3], [7, 5], [4, 1], [5, 5]]):\n    # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\"\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves graph theory, permutations and combinations, and set operations.",
        "description": "Find the solution: list of integers that should uniquely map to pairs of integers in two given lists, satisfying specific constraints.",
        "quality": 1,
        "fitness": 0.41290244460105896
    },
    {
        "program_str": "def f(cut_position: int, ring='ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf', lower=1) -> bool:\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= 1 if matches[c] > 0 else len(line)\n        else:\n            matches[c.lower()] += 1\n    return sum((i == 0 for i in matches.values())) >= lower\ndef g(ring = 'ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf', lower = 1):\n    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic to solve the challenge.",
        "description": "Find the solution: cut_position (integer) that should ensure that all characters in the rotated ring are matched with their corresponding uppercase or lowercase characters, with at least 'lower' number of matches.",
        "quality": 1,
        "fitness": 0.41277876496315
    },
    {
        "program_str": "from typing import List \ndef f(nums: List[int], b=7, m=26) -> bool:\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j) -> bool:\n        (r, s) = (max(i, j), min(i, j))\n        while s >= 1:\n            (r, s) = (s, r % s)\n        return r\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all((any((i != j and gcd(i, j) > 1 for j in nums)) for i in nums))\n    return True\ndef g(b = 7, m = 26):\n    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as recursion, set operations, permutations and combinations, number theory, and algorithm optimization.",
        "description": "Find the solution: nums (a list of integers) that should have a length equal to a specified value 'm', contain unique elements, and have the minimum element greater than or equal to 0.",
        "quality": 1,
        "fitness": 0.49486979842185974
    },
    {
        "program_str": "from typing import List \ndef f(indices: List[int], a0=2362263) -> bool:\n    assert a0 >= 0 and a0 % 3 == 0, 'Hint: a_0 is a multiple of 3.'\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and (len({s[i] for i in indices}) == 1)\ndef g(a0 = 2362263):\n    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, recursion, and set operations.",
        "description": "Find the solution: indices (List[int]) that should uniquely identify specific elements in a sequence generated based on a mathematical rule, ensuring no duplicates and meeting specific constraints.",
        "quality": 1,
        "fitness": 0.48639097809791565
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int], n=9) -> bool:\n    assert n % 3 == 0, 'Hint: n is a multiple of 3'\n    return len(li) == n and all((li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n)))\ndef g(n = 9):\n    return [-1, -1, 2] * (n // 3)\nassert f(g()) == True",
        "emb": [
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, conditional logic, and mathematical operations.",
        "description": "Find the solution: list of integers `li` that should satisfy the condition where each element in the list is related to the previous two elements in a specific mathematical relationship, and the length of the list should be a multiple of 3.",
        "quality": 1,
        "fitness": 0.5474091172218323
    },
    {
        "program_str": "from typing import List \ndef f(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]) -> bool:\n    return all((sum((v >> i & 1 for i in inds)) % 2 == 1 for v in vecs))\ndef g(vecs = [22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Binary Operations (bitwise shifting, AND, OR), Array Indexing",
        "description": "Find the solution: a list of indices (ints) that should have odd parity when summing the corresponding bits of the numbers in the given list of vectors, ensuring that the sum of each bit position across all vectors is odd.",
        "quality": 1,
        "fitness": 0.4209928810596466
    },
    {
        "program_str": "from typing import List \ndef f(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]) -> bool:\n    return sum((sum((v >> i & 1 for i in inds)) % 2 for v in vecs)) >= len(vecs) * 3 / 4\ndef g(vecs = [576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves bitwise operations, brute force search, randomization, and probability/statistics.",
        "description": "Find the solution: a list of indices (ints) that should ensure that the majority of the bits at those indices in the given list of vectors are set to 1.",
        "quality": 1,
        "fitness": 0.4697701334953308
    },
    {
        "program_str": "def f(n: int, a=247586288427023352, b=372021520735824432, lower_bound=1709054537) -> bool:\n    return a % n == 0 and b % n == 0 and (n >= lower_bound)\ndef g(a = 247586288427023352, b = 372021520735824432, lower_bound = 1709054537):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and number theory.",
        "description": "Find the solution: n (integer) that should be a factor of both a and b, and greater than or equal to the lower bound.",
        "quality": 1,
        "fitness": 0.5530473589897156
    },
    {
        "program_str": "def f(n: int, nums=[77410, 23223, 54187], lower_bound=2) -> bool:\n    return all((i % n == 0 for i in nums)) and n >= lower_bound\ndef g(nums = [77410, 23223, 54187], lower_bound = 2):\n    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and recursion.",
        "description": "Find the solution: an integer `n` that should be a factor of all numbers in the list `nums` and greater than or equal to the specified lower bound.",
        "quality": 1,
        "fitness": 0.5492885112762451
    },
    {
        "program_str": "def f(n: int, a=79680, b=661339968, upper_bound=410128528659) -> bool:\n    return n % a == 0 and n % b == 0 and (0 < n <= upper_bound)\ndef g(a = 79680, b = 661339968, upper_bound = 410128528659):\n    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and number theory.",
        "description": "Find the solution: n (integer) that should be divisible by both a and b, within the specified upper bound, to satisfy all constraints of the puzzle.",
        "quality": 1,
        "fitness": 0.5875327587127686
    },
    {
        "program_str": "def f(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888) -> bool:\n    return all((n % i == 0 for i in nums)) and 0 < n <= upper_bound\ndef g(nums = [46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound = 82396663973139497934429093888):\n    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and number theory.",
        "description": "Find the solution: an integer `n` that should be divisible by all numbers in the list `nums` and within the range of 0 to `upper_bound`.",
        "quality": 1,
        "fitness": 0.5289561152458191
    },
    {
        "program_str": "from typing import List \ndef f(nums: List[int], n=12345) -> bool:\n    return len(nums) <= 4 and sum((i ** 2 for i in nums)) == n\ndef g(n = 12345):\n    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\"\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, set operations, and brute force search.",
        "description": "Find the solution: nums (a list of integers) that should have a length less than or equal to 4 and the sum of the squares of its elements should equal the value of n.",
        "quality": 1,
        "fitness": 0.5141410827636719
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int], k=6) -> bool:\n\n    def prod(nums) -> bool:\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n    return min(li) > 1 and len(li) == k and all(((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k)))\ndef g(k = 6):\n    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations, conditional logic, and list manipulation.",
        "description": "Find the solution: list of integers `li` that should have a minimum value greater than 1, a length equal to `k`, and satisfy a specific mathematical condition involving the product of all elements in the list.",
        "quality": 1,
        "fitness": 0.5181315541267395
    },
    {
        "program_str": "def f(n: int) -> bool:\n    return pow(2, n, n) == 3\ndef g():\n    return 4700063497\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and number theory, specifically the use of the pow() function and checking for a specific condition.",
        "description": "Find the solution: n (integer) that should be able to satisfy the condition pow(2, n, n) == 3.",
        "quality": 1,
        "fitness": 0.6052411794662476
    },
    {
        "program_str": "def f(n: int, year_len=2) -> bool:\n    import random\n    random.seed(0)\n    K = 1000\n    prob = sum((len({random.randrange(year_len) for i in range(n)}) < n for j in range(K))) / K\n    return (prob - 0.5) ** 2 <= year_len\ndef g(year_len = 2):\n    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability and statistics, as well as mathematical operations. It also includes a loop and conditional logic to find the best value of n. The solution uses recursion to calculate the distinct probability. Overall, the puzzle covers topics such as Probability and Statistics, Mathematical Operations, Conditional Logic, and Recursion.",
        "description": "Find the solution: n (an integer) that should minimize the probability of having a subset of size less than n with distinct random numbers generated within a given range, such that the squared difference between this probability and 0.5 is less than or equal to the specified year length.",
        "quality": 1,
        "fitness": 0.4613306224346161
    },
    {
        "program_str": "from typing import List \ndef f(counts: List[int], target_prob=0.7142857142857143) -> bool:\n    (m, n) = counts\n    probs = [1.0] + [0.0] * n\n    for i in range(2, m + 1):\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = j / (i + j) * probs[j - 1] + i / (i + j) * old_probs[j]\n    return abs(probs[n] - target_prob) < 1e-06\ndef g(target_prob = 0.7142857142857143):\n    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]\nassert f(g()) == True",
        "emb": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves probability calculations and optimization techniques to find the correct values of m and n. It also includes mathematical operations and conditional logic to check the condition for the solution. Additionally, it requires understanding of loops and list manipulation in Python.",
        "description": "Find the solution: counts (List[int]) that should determine the probabilities of a specific event occurring, such that the final probability matches the target probability within a small margin of error.",
        "quality": 1,
        "fitness": 0.47784945368766785
    },
    {
        "program_str": "def f(st: str, a='zine', b='cerofilimybazine') -> bool:\n    return st + a == b\ndef g(a = 'zine', b = 'cerofilimybazine'):\n    return b[:len(b) - len(a)]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "description": "Find the solution: string `st` that should concatenate with argument `a` to equal argument `b`.",
        "quality": 1,
        "fitness": 0.5984418392181396
    },
    {
        "program_str": "def f(s: str, n=1000) -> bool:\n    return len(s) == n\ndef g(n = 1000):\n    return 'a' * n\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "description": "Find the solution: s (a string) that should have a length of 1000 characters.",
        "quality": 1,
        "fitness": 0.6242722868919373
    },
    {
        "program_str": "from typing import List \ndef f(inds: List[int], s='kibozekiboze', target='') -> bool:\n    (i, j, k) = inds\n    return s[i:j:k] == target\ndef g(s = 'kibozekiboze', target = ''):\n    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String manipulation using slicing and itertools product for generating indices",
        "description": "Find the solution: a list of integers that should represent the indices (i, j, k) to slice the string 'kibozekiboze' in a way that the sliced portion matches the target string.",
        "quality": 1,
        "fitness": 0.5720086693763733
    },
    {
        "program_str": "def f(s: str, big_str='fatextemedyrotichipicecojon', index=24) -> bool:\n    return big_str.index(s) == index\ndef g(big_str = 'fatextemedyrotichipicecojon', index = 24):\n    return big_str[index:]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and indexing in an array. The solution function g() extracts a substring from a given index in a big string and the puzzle function f() checks if the extracted substring matches a specific index.",
        "description": "Find the solution: s (a string) that should be a substring of the big_str such that its index in big_str is equal to the specified index (24 in this case).",
        "quality": 1,
        "fitness": 0.6254903674125671
    },
    {
        "program_str": "def f(big_str: str, sub_str='nofufaxunetextesitocedezyxuxexyfoquichitiracyquat', index=185) -> bool:\n    return big_str.index(sub_str) == index\ndef g(sub_str = 'nofufaxunetextesitocedezyxuxexyfoquichitiracyquat', index = 185):\n    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: big_str (string) that should contain the substring 'nofufaxunetextesitocedezyxuxexyfoquichitiracyquat' at index 185.",
        "quality": 1,
        "fitness": 0.5362457036972046
    },
    {
        "program_str": "def f(s: str, a='bafywihequyjicivicharyquynikixuhinyqu', b='syrapetagecvicharyquynirorazecheth', length=12) -> bool:\n    return len(s) == length and s in a and (s in b)\ndef g(a = 'bafywihequyjicivicharyquynikixuhinyqu', b = 'syrapetagecvicharyquynirorazecheth', length = 12):\n    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: s (a string) that should be of length 12 and present in both strings a and b.",
        "quality": 1,
        "fitness": 0.5731788873672485
    },
    {
        "program_str": "from typing import List \ndef f(substrings: List[str], s='hello', count=15) -> bool:\n    return len(substrings) == len(set(substrings)) >= count and all((sub in s for sub in substrings))\ndef g(s = 'hello', count = 15):\n    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations to find unique substrings of a given string. It also includes list comprehension and sorting. The solution uses a brute force approach to generate all possible substrings and then filter out duplicates.",
        "description": "Find the solution: substrings (strings) that should not contain any duplicates and must all be present in the string 'hello' at least once. The number of unique substrings should be greater than or equal to the specified count.",
        "quality": 1,
        "fitness": 0.4715195894241333
    },
    {
        "program_str": "def f(string: str, substring='moz', count=70, length=210) -> bool:\n    return string.count(substring) == count and len(string) == length\ndef g(substring = 'moz', count = 70, length = 210):\n    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "description": "Find the solution: string that should have a count of 'moz' equal to 70 and a length of 210 characters.",
        "quality": 1,
        "fitness": 0.45919936895370483
    },
    {
        "program_str": "def f(x: str, parts=[], string='') -> bool:\n    return x.join(parts) == string\ndef g(parts = [], string = ''):\n    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "String Manipulation, Array Indexing",
        "description": "Find the solution: a string `x` that should join the list of strings `parts` to match the string `string`.",
        "quality": 1,
        "fitness": 0.5243054032325745
    },
    {
        "program_str": "from typing import List \ndef f(parts: List[str], sep='xusoquyvamathila', string='bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji') -> bool:\n    return sep.join(parts) == string and all((sep not in p for p in parts))\ndef g(sep = 'xusoquyvamathila', string = 'bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji'):\n    return string.split(sep)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "String Manipulation, Conditional Logic",
        "description": "Find the solution: a list of strings that, when joined with a specific separator, matches a given string and none of the strings contain the separator.",
        "quality": 1,
        "fitness": 0.552165150642395
    },
    {
        "program_str": "from typing import List \ndef f(li: List[int], dups=23476) -> bool:\n    return len(set(li)) == len(li) - dups\ndef g(dups = 23476):\n    return [1] * (dups + 1)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves topics such as List Manipulation, Set Operations, and Assertions.",
        "description": "Find the solution: list of integers `li` that should have no duplicate elements, with the number of duplicates specified by the argument `dups`.",
        "quality": 1,
        "fitness": 0.5780764818191528
    },
    {
        "program_str": "def f(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18) -> bool:\n    return li[i] == target\ndef g(li = [17, 31, 91, 18, 42, 1, 9], target = 18):\n    return li.index(target)\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves searching for an element in a list using index operations.",
        "description": "Find the solution: an integer `i` that should be the index of the element in the list `li` that matches the target value.",
        "quality": 1,
        "fitness": 0.5603808164596558
    },
    {
        "program_str": "def f(i: int, li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42) -> bool:\n    return li[i] == target and i < 0\ndef g(li = [-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target = -42):\n    return li.index(target) - len(li)\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation, indexing, and conditional logic.",
        "description": "Find the solution: an integer `i` that should point to the target value `-42` in the list `li` and `i` should be negative.",
        "quality": 1,
        "fitness": 0.5256922245025635
    },
    {
        "program_str": "from typing import List \ndef f(inds: List[int], li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]) -> bool:\n    (i, j, k) = inds\n    return li[i:j:k] == target\ndef g(li = [-72, 70, 50, -41, 94, -82, -74, 8, -23], target = [-82]):\n    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass\nassert f(g()) == True",
        "emb": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "Array Indexing, Permutations and Combinations",
        "description": "Find the solution: a list of integers that should slice the given list `li` to match the target list `target` when using the specified indices.",
        "quality": 1,
        "fitness": 0.4860404431819916
    },
    {
        "program_str": "def f(x: int, a=93252338) -> bool:\n    return -x == a\ndef g(a = 93252338):\n    return - a\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "description": "Find the solution: x (integer) that should be equal to the negative of the value of a, where a is a predefined integer constant.",
        "quality": 1,
        "fitness": 0.6197203397750854
    },
    {
        "program_str": "def f(x: int, a=1073258, b=72352549) -> bool:\n    return a + x == b\ndef g(a = 1073258, b = 72352549):\n    return b - a\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations and Conditional Logic.",
        "description": "Find the solution: x (integer) that should satisfy the constraint a + x = b, where a and b are given integer values.",
        "quality": 1,
        "fitness": 0.6128483414649963
    },
    {
        "program_str": "def f(x: int, a=9688203125538303, b=-293093369321912) -> bool:\n    return x - a == b\ndef g(a = 9688203125538303, b = -293093369321912):\n    return a + b\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "description": "Find the solution: x (integer) that should satisfy the constraint x - 9688203125538303 == -293093369321912.",
        "quality": 1,
        "fitness": 0.5821285247802734
    },
    {
        "program_str": "def f(x: int, a=-8783800228130606, b=-508993556991975) -> bool:\n    return a - x == b\ndef g(a = -8783800228130606, b = -508993556991975):\n    return a - b\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic.",
        "description": "Find the solution: x (integer) that should satisfy the equation a - x = b, where a and b are predefined values.",
        "quality": 1,
        "fitness": 0.5769055485725403
    },
    {
        "program_str": "def f(n: int, a=-141336, b=72) -> bool:\n    return b * n + a % b == a\ndef g(a = -141336, b = 72):\n    return a // b\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves Mathematical Operations and Conditional Logic.",
        "description": "Find the solution: n (integer) that should satisfy the equation b * n + a % b == a, where a=-141336 and b=72.",
        "quality": 1,
        "fitness": 0.6099963784217834
    },
    {
        "program_str": "def f(n: int, a=12, b=-9988218457242775) -> bool:\n    return b // n == a\ndef g(a = 12, b = -9988218457242775):\n    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves Mathematical Operations and Conditional Logic.",
        "description": "Find the solution: n (integer) that should divide b by n to equal a.",
        "quality": 1,
        "fitness": 0.6024380326271057
    },
    {
        "program_str": "def f(n: int, a=-3411193412414137, b=-9070455318026063) -> bool:\n    return n // b == a\ndef g(a = -3411193412414137, b = -9070455318026063):\n    return a * b\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic.",
        "description": "Find the solution: n (integer) that should satisfy the constraint n // -9070455318026063 == -3411193412414137.",
        "quality": 1,
        "fitness": 0.5866568684577942
    },
    {
        "program_str": "def f(x: int, a=2617350631613713636) -> bool:\n    return x ** 2 == a\ndef g(a = 2617350631613713636):\n    return int(a ** 0.5)\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic.",
        "description": "Find the solution: x (integer) that should be the square root of the constant value a to solve the puzzle.",
        "quality": 1,
        "fitness": 0.6304230093955994
    },
    {
        "program_str": "def f(x: float, a=2732656229) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3)\ndef g(a = 2732656229):\n    return a ** 0.5\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves mathematical operations and conditional logic.",
        "description": "Find the solution: x (float) that should be the square root of a specific number a, with a precision of 10 ** (-3).",
        "quality": 1,
        "fitness": 0.6116828918457031
    },
    {
        "program_str": "def f(x: float, a=1363713245) -> bool:\n    return abs(x ** 2 - a) < 10 ** (-3) and x < 0\ndef g(a = 1363713245):\n    return -a ** 0.5\nassert f(g()) == True",
        "emb": [
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves mathematical operations and conditional logic.",
        "description": "Find the solution: x (float) that should be a negative number whose square is approximately equal to 1363713245 within a small margin of error.",
        "quality": 1,
        "fitness": 0.6096465587615967
    },
    {
        "program_str": "def f(s: str) -> bool:\n    return 'Hello ' + s == 'Hello world'\ndef g():\n    return \"world\"\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "This puzzle involves string manipulation and conditional logic.",
        "description": "Find the solution: s (a string) that should concatenate with 'Hello ' to form 'Hello world'.",
        "quality": 1,
        "fitness": 0.6494660377502441
    },
    {
        "program_str": "def f(s: str) -> bool:\n    return 'Hello ' + s[::-1] == 'Hello world'\ndef g():\n    return \"world\"[::-1]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ],
        "explanation_emb": "String Manipulation, Array Indexing",
        "description": "Find the solution: s (a string) that should be concatenated with its reverse to form the string 'Hello world'.",
        "quality": 1,
        "fitness": 0.6342331767082214
    },
    {
        "program_str": "from typing import List \ndef f(x: List[int]) -> bool:\n    return len(x) == 2 and sum(x) == 3\ndef g():\n    return [1, 2]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves list manipulation and conditional logic.",
        "description": "Find the solution: a list of two integers that should have a length of 2 and sum up to 3.",
        "quality": 1,
        "fitness": 0.613961935043335
    },
    {
        "program_str": "from typing import List \ndef f(s: List[str]) -> bool:\n    return len(set(s)) == 1000 and all((x.count('a') > x.count('b') and 'b' in x for x in s))\ndef g():\n    return [\"a\" * (i + 2) + \"b\" for i in range(1000)]\nassert f(g()) == True",
        "emb": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        "explanation_emb": "The puzzle involves string manipulation and set operations to check for uniqueness and specific character counts in a list of strings.",
        "description": "Find the solution: a list of strings that should have a length of 1000 and each string must have more occurrences of 'a' than 'b', and 'b' must be present in each string.",
        "quality": 1,
        "fitness": 0.5621559023857117
    }
]