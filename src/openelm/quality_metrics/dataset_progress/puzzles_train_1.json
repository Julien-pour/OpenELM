[{"name": "Tutorial5:0", "sat": "def sat(n: int):\n    return str(n * n).startswith(\"123456789\")", "ans_type": "int", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find an integer whose perfect square begins with 123456789 in its decimal representation.\"\"\"", "sol_bodies": ["    return int(int(\"123456789\" + \"0\" * 9) ** 0.5) + 1"], "module": "tutorial.py", "notes": "", "weight": 1.0}, {"name": "Study_1:0", "sat": "def sat(s: str):\n    return s.count('o') == 1000 and s.count('oo') == 0", "ans_type": "str", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a string with 1000 'o's but no two adjacent 'o's.\"\"\"", "sol_bodies": ["    return ('h' + 'o') * 1000"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_3:0", "sat": "def sat(li: List[int]):\n    return sorted(li) == list(range(999)) and all(li[i] != i for i in range(len(li)))", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a permutation of [0, 1, ..., 998] such that the ith element is *not* i, for all i=0, 1, ..., 998.\"\"\"", "sol_bodies": ["    return [((i + 1) % 999) for i in range(999)]"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_5:0", "sat": "def sat(li: List[int]):\n    return all([li.count(i) == i for i in range(10)])", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a list integers such that the integer i occurs i times, for i = 0, 1, 2, ..., 9.\"\"\"", "sol_bodies": ["    return [i for i in range(10) for j in range(i)]"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_7:0", "sat": "def sat(s: str):\n    return str(8 ** 2888).count(s) > 8 and len(s) == 3", "ans_type": "str", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a three-digit pattern  that occurs more than 8 times in the decimal representation of 8^2888.\"\"\"", "sol_bodies": ["    s = str(8 ** 2888)\n    return max({s[i: i + 3] for i in range(len(s) - 2)}, key=lambda t: s.count(t))"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_9:0", "sat": "def sat(li: List[int]):\n    return [\"The quick brown fox jumps over the lazy dog\"[i] for i in li] == list(\n        \"The five boxing wizards jump quickly\")", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Find a way to rearrange the letters in the pangram \"The quick brown fox jumps over the lazy dog\" to get\n    the pangram \"The five boxing wizards jump quickly\". The answer should be represented as a list of index\n    mappings.\n    \"\"\"", "sol_bodies": ["    return ['The quick brown fox jumps over the lazy dog'.index(t)\n            for t in 'The five boxing wizards jump quickly']"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_11:0", "sat": "def sat(ls: List[str]):\n    return min(ls) == max(ls) == str(len(ls))", "ans_type": "List[str]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Find a list of strings whose length (viewed as a string) is equal to the lexicographically largest element\n    and is equal to the lexicographically smallest element.\n    \"\"\"", "sol_bodies": ["    return ['1']"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_13:0", "sat": "def sat(x: float):\n    return str(x - 3.1415).startswith(\"123.456\")", "ans_type": "float", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a real number which, when you subtract 3.1415, has a decimal representation starting with 123.456.\"\"\"", "sol_bodies": ["    return 123.456 + 3.1415"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_15:0", "sat": "def sat(li: List[int]):\n    return all(sum(li[:i]) == 2 ** i - 1 for i in range(20))", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a list of integers such that the sum of the first i integers is 2^i -1, for i = 0, 1, 2, ..., 19.\"\"\"", "sol_bodies": ["    return [(2 ** i) for i in range(20)]"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_17:0", "sat": "def sat(i: int):\n    return len(str(i + 1000)) > len(str(i + 1001))", "ans_type": "int", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a number whose decimal representation is *a longer string* when you add 1,000 to it than when you add 1,001.\"\"\"", "sol_bodies": ["    return -1001"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_19:0", "sat": "def sat(li: List[int]):\n    return {i + j for i in li for j in li} == {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Find a list of integers whose pairwise sums make the set {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    That is find L such that, { i + j | i, j in L } = {0, 1, 2, 3, 4, 5, 6, 17, 18, 19, 20, 34}.\n    \"\"\"", "sol_bodies": ["    return [0, 1, 2, 3, 17]"], "module": "study.py", "notes": "9/15/2021 Updated to take a list rather than a set because it was the only puzzle in the repo with Set argument.", "weight": 1.0}, {"name": "Study_21:0", "sat": "def sat(li: List[int]):\n    return all([li[i] != li[i + 1] for i in range(10)]) and len(set(li)) == 3", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Find a list integers containing exactly three distinct values, such that no integer repeats\n    twice consecutively among the first eleven entries. (So the list needs to have length greater than ten.)\n    \"\"\"", "sol_bodies": ["    return list(range(3)) * 10"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_23:0", "sat": "def sat(ls: List[str]):\n    return tuple(ls) in zip('dee', 'doo', 'dah!')", "ans_type": "List[str]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Find a list of characters which are aligned at the same indices of the three strings 'dee', 'doo', and 'dah!'.\n    \"\"\"", "sol_bodies": ["    return list(next(zip('dee', 'doo', 'dah!')))"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_25:0", "sat": "def sat(s: str):\n    return sorted(s) == sorted('Permute me true') and s == s[::-1]", "ans_type": "str", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a permutation of the string 'Permute me true' which is a palindrome.\"\"\"", "sol_bodies": ["    s = sorted('Permute me true'[1:])[::2]\n    return \"\".join(s + ['P'] + s[::-1])"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_27:0", "sat": "def sat(li: List[int]):\n    return li[li[0]] != li[li[1]] and li[li[li[0]]] == li[li[li[1]]]", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Consider a digraph where each node has exactly one outgoing edge. For each edge (u, v), call u the parent and\n    v the child. Then find such a digraph where the grandchildren of the first and second nodes differ but they\n    share the same great-grandchildren. Represented this digraph by the list of children indices.\n    \"\"\"", "sol_bodies": ["    return [1, 2, 3, 3]"], "module": "study.py", "notes": "", "weight": 1.0}, {"name": "Study_29:0", "sat": "def sat(l: List[int]):\n    return all(i in range(1000) and abs(i * i - j * j) >= 10 for i in l for j in l if i != j) and len(set(l)) > 995", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Find a list of more than 995 distinct integers between 0 and 999, inclusive, such that each pair of integers\n    have squares that differ by at least 10.\n    \"\"\"", "sol_bodies": ["    return [0, 4] + list(range(6, 1000))"], "module": "study.py", "notes": "9/15/2021: updated to a list since sets were removed from puzzle formats", "weight": 1.0}, {"name": "ClockAngle:4", "sat": "def sat(hands: List[int], target_angle=68):\n    h, m = hands\n    assert 0 < h <= 12 and 0 <= m < 60\n    hour_angle = 30 * h + m / 2\n    minute_angle = 6 * m\n    return abs(hour_angle - minute_angle) in [target_angle, 360 - target_angle]", "ans_type": "List[int]", "sol_header": "def sol(target_angle=68):", "sol_docstring": "    \"\"\"Find clock hands = [hour, min] such that the angle is target_angle degrees.\"\"\"", "sol_bodies": ["    for h in range(1, 13):\n        for m in range(60):\n            hour_angle = 30 * h + m / 2\n            minute_angle = 6 * m\n            if abs(hour_angle - minute_angle) % 360 in [target_angle, 360 - target_angle]:\n                return [h, m]"], "module": "classic_puzzles.py", "notes": "[Clock Angle Problem](https://en.wikipedia.org/wiki/Clock_angle_problem), easy variant", "weight": 1.0}, {"name": "Kirkman:0", "sat": "def sat(daygroups: List[List[List[int]]]):\n    assert len(daygroups) == 7\n    assert all(len(groups) == 5 and {i for g in groups for i in g} == set(range(15)) for groups in daygroups)\n    assert all(len(g) == 3 for groups in daygroups for g in groups)\n    return len({(i, j) for groups in daygroups for g in groups for i in g for j in g}) == 15 * 15", "ans_type": "List[List[List[int]]]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Arrange 15 people into groups of 3 each day for seven days so that no two people are in the same group twice.\n    \"\"\"", "sol_bodies": ["    from itertools import combinations\n    import random\n    rand = random.Random(0)\n    days = [[list(range(15)) for _2 in range(2)] for _ in range(7)]  # each day is pi, inv\n    counts = {(i, j): (7 if j in range(k, k + 3) else 0)\n              for k in range(0, 15, 3)\n              for i in range(k, k + 3)\n              for j in range(15) if j != i\n              }\n\n    todos = [pair for pair, count in counts.items() if count == 0]\n    while True:\n        pair = rand.choice(todos)  # choose i and j to make next to each other on some day\n        if rand.randrange(2):\n            pair = pair[::-1]\n\n        a, u = pair\n        pi, inv = rand.choice(days)\n        assert pi[inv[a]] == a and pi[inv[u]] == u\n        bases = [3 * (inv[i] // 3) for i in pair]\n        (b, c), (v, w) = [[x for x in pi[b: b + 3] if x != i] for i, b in zip(pair, bases)]\n        if rand.randrange(2):\n            b, c, = c, b\n        # current (a, b, c) (u, v, w). consider swap of u with b to make (a, u, c) (b, v, w)\n\n        new_pairs = [(a, u), (c, u), (b, v), (b, w)]\n        old_pairs = [(u, v), (u, w), (b, a), (b, c)]\n        gained = sum(counts[p] == 0 for p in new_pairs)\n        lost = sum(counts[p] == 1 for p in old_pairs)\n        if rand.random() <= 100 ** (gained - lost):\n            for p in new_pairs:\n                counts[p] += 1\n                counts[p[::-1]] += 1\n            for p in old_pairs:\n                counts[p] -= 1\n                counts[p[::-1]] -= 1\n            pi[inv[b]], pi[inv[u]], inv[b], inv[u] = u, b, inv[u], inv[b]\n            todos = [pair for pair, count in counts.items() if count == 0]\n            if len(todos) == 0:\n                return [[pi[k:k + 3] for k in range(0, 15, 3)] for pi, _inv in days]"], "module": "classic_puzzles.py", "notes": "[Kirkman's problem](https://en.wikipedia.org/wiki/Kirkman%27s_schoolgirl_problem)", "weight": 1.0}, {"name": "MonkeyAndCoconuts:0", "sat": "def sat(n: int):\n    for i in range(5):\n        assert n % 5 == 1\n        n -= 1 + (n - 1) // 5\n    return n > 0 and n % 5 == 1", "ans_type": "int", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Find the number of coconuts to solve the following riddle:\n        There is a pile of coconuts, owned by five men. One man divides the pile into five equal piles, giving the\n        one left over coconut to a passing monkey, and takes away his own share. The second man then repeats the\n        procedure, dividing the remaining pile into five and taking away his share, as do the third, fourth, and\n        fifth, each of them finding one coconut left over when dividing the pile by five, and giving it to a monkey.\n        Finally, the group divide the remaining coconuts into five equal piles: this time no coconuts are left over.\n        How many coconuts were there in the original pile?\n                                          Quoted from https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts\n    \"\"\"", "sol_bodies": ["    m = 1\n    while True:\n        n = m\n        for i in range(5):\n            if n % 5 != 1:\n                break\n            n -= 1 + (n - 1) // 5\n        if n > 0 and n % 5 == 1:\n            return m\n        m += 5"], "module": "classic_puzzles.py", "notes": "[The Monkey and the Coconuts](https://en.wikipedia.org/wiki/The_monkey_and_the_coconuts)", "weight": 1.0}, {"name": "No3Colinear:0", "sat": "def sat(coords: List[List[int]], side=10, num_points=20):\n    for i1 in range(len(coords)):\n        x1, y1 = coords[i1]\n        assert 0 <= x1 < side and 0 <= y1 < side\n        for i2 in range(i1):\n            x2, y2 = coords[i2]\n            for i3 in range(i2):\n                x3, y3 = coords[i3]\n                assert x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0\n    return len({(a, b) for a, b in coords}) == len(coords) >= num_points", "ans_type": "List[List[int]]", "sol_header": "def sol(side=10, num_points=20):", "sol_docstring": "    \"\"\"Find num_points points in an side x side grid such that no three points are collinear.\"\"\"", "sol_bodies": ["    from itertools import combinations\n    assert side <= 5 or side == 10, \"Don't know how to solve other sides\"\n\n    def test(coords):\n        return all(p[0] * (q[1] - r[1]) + q[0] * (r[1] - p[1]) + r[0] * (p[1] - q[1])\n                   for p, q, r in combinations(coords, 3))\n\n    if side <= 5:\n        grid = [[i, j] for i in range(side) for j in range(side)]\n        return next(list(coords) for coords in combinations(grid, num_points) if test(coords))\n\n    if side == 10:\n        def mirror(coords):  # rotate to all four corners\n            return [[a, b] for x, y in coords for a in [x, side - 1 - x] for b in [y, side - 1 - y]]\n\n        grid = [[i, j] for i in range(side // 2) for j in range(side // 2)]\n        return next(list(mirror(coords)) for coords in combinations(grid, side // 2) if\n                    test(coords) and test(mirror(coords)))"], "module": "classic_puzzles.py", "notes": "[No three-in-a-line](https://en.wikipedia.org/wiki/No-three-in-line_problem)", "weight": 1.0}, {"name": "PostageStamp:1", "sat": "def sat(stamps: List[int], target=271, max_stamps=8, options=[37, 37, 12, 87, 39]):\n    for s in stamps:\n        assert s in options\n    return len(stamps) <= max_stamps and sum(stamps) == target", "ans_type": "List[int]", "sol_header": "def sol(target=271, max_stamps=8, options=[37, 37, 12, 87, 39]):", "sol_docstring": "    \"\"\"Find a selection of at most max_stamps stamps whose total worth is the target value.\"\"\"", "sol_bodies": ["    from itertools import combinations_with_replacement\n    for n in range(max_stamps + 1):\n        for c in combinations_with_replacement(options, n):\n            if sum(c) == target:\n                return list(c)"], "module": "classic_puzzles.py", "notes": "[Postage stamp problem](https://en.wikipedia.org/wiki/Postage_stamp_problem)", "weight": 1.0}, {"name": "SquaringTheSquare:0", "sat": "def sat(xy_sides: List[List[int]]):\n    n = max(x + side for x, y, side in xy_sides)\n    assert len({side for x, y, side in xy_sides}) == len(xy_sides) > 1\n    for x, y, s in xy_sides:\n        assert 0 <= y < y + s <= n and 0 <= x\n        for x2, y2, s2 in xy_sides:\n            assert s2 <= s or x2 >= x + s or x2 + s2 <= x or y2 >= y + s or y2 + s2 <= y\n\n    return sum(side ** 2 for x, y, side in xy_sides) == n ** 2", "ans_type": "List[List[int]]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Partition a square into smaller squares with unique side lengths. A perfect squared path has distinct sides.\n    xy_sides is a List of (x, y, side)\n    \"\"\"", "sol_bodies": ["    return [[0, 0, 50], [0, 50, 29], [0, 79, 33], [29, 50, 25], [29, 75, 4], [33, 75, 37], [50, 0, 35],\n            [50, 35, 15], [54, 50, 9], [54, 59, 16], [63, 50, 2], [63, 52, 7], [65, 35, 17], [70, 52, 18],\n            [70, 70, 42], [82, 35, 11], [82, 46, 6], [85, 0, 27], [85, 27, 8], [88, 46, 24], [93, 27, 19]]"], "module": "classic_puzzles.py", "notes": "[Squaring the square](https://en.wikipedia.org/wiki/Squaring_the_square)\nWikipedia gives a minimal [solution with 21 squares](https://en.wikipedia.org/wiki/Squaring_the_square)\ndue to Duijvestijn (1978).", "weight": 1.0}, {"name": "NecklaceSplit:2", "sat": "def sat(n: int, lace=\"brrrbrrbrbbbbbrrbbrr\"):\n    sub = lace[n: n + len(lace) // 2]\n    return n >= 0 and lace.count(\"r\") == 2 * sub.count(\"r\") and lace.count(\"b\") == 2 * sub.count(\"b\")", "ans_type": "int", "sol_header": "def sol(lace=\"brrrbrrbrbbbbbrrbbrr\"):", "sol_docstring": "    \"\"\"\n    Find a split dividing the given red/blue necklace in half at n so that each piece has an equal number of\n    reds and blues.\n    \"\"\"", "sol_bodies": ["    if lace == \"\":\n        return 0\n    return next(n for n in range(len(lace) // 2) if lace[n: n + len(lace) // 2].count(\"r\") == len(lace) // 4)"], "module": "classic_puzzles.py", "notes": "[Necklace Splitting Problem](https://en.wikipedia.org/wiki/Necklace_splitting_problem)", "weight": 1.0}, {"name": "PandigitalSquare:0", "sat": "def sat(n: int):\n    s = str(n * n)\n    for i in \"0123456789\":\n        assert s.count(i) == 1\n    return True", "ans_type": "int", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find an integer whose square has all digits 0-9 once.\"\"\"", "sol_bodies": ["    for n in range(10 ** 5):\n        if sorted([int(s) for s in str(n * n)]) == list(range(10)):\n            return n"], "module": "classic_puzzles.py", "notes": "[Pandigital](https://en.wikipedia.org/wiki/Pandigital_number) Square", "weight": 1.0}, {"name": "Easy63:0", "sat": "def sat(s: str):\n    return set(s) <= set(\"18-+*/\") and s.count(\"8\") == 2 and s.count(\"1\") == 1 and eval(s) == 63", "ans_type": "str", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a formula using two 8s and two 1's and -+*/ that evaluates to 1.\"\"\"", "sol_bodies": ["    return \"8*8-1\""], "module": "classic_puzzles.py", "notes": "An easy puzzle to make 63 using two 8's and one 1's.", "weight": 1.0}, {"name": "Harder63:0", "sat": "def sat(s: str):\n    return set(s) <= set(\"18-+*/\") and s.count(\"8\") == 3 and s.count(\"1\") == 1 and eval(s) == 63", "ans_type": "str", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find an expression using two 8s and two 1's and -+*/ that evaluates to 1.\"\"\"", "sol_bodies": ["    return \"8*8-1**8\""], "module": "classic_puzzles.py", "notes": "An harder puzzle to make 63 using three 8's and one 1's.", "weight": 1.0}, {"name": "WaterPouring:1", "sat": "def sat(moves: List[List[int]], capacities=[724, 43, 611], init=[72, 2, 269], goal=[56, 0, 287]):\n    state = init.copy()\n\n    for [i, j] in moves:\n        assert min(i, j) >= 0, \"Indices must be non-negative\"\n        assert i != j, \"Cannot pour from same state to itself\"\n        n = min(capacities[j], state[i] + state[j])\n        state[i], state[j] = state[i] + state[j] - n, n\n\n    return state == goal", "ans_type": "List[List[int]]", "sol_header": "def sol(init=[72, 2, 269], goal=[56, 0, 287], capacities=[724, 43, 611]):", "sol_docstring": "    \"\"\"\n    Given an initial state of water quantities in jugs and jug capacities, find a sequence of moves (pouring\n    one jug into another until it is full or the first is empty) to reaches the given goal state.\n    moves is list of [from, to] pairs\n    \"\"\"", "sol_bodies": ["    from collections import deque\n    num_jugs = len(capacities)\n    start = tuple(init)\n    target = tuple(goal)\n    trails = {start: ([], start)}\n    queue = deque([tuple(init)])\n    while target not in trails:\n        state = queue.popleft()\n        for i in range(num_jugs):\n            for j in range(num_jugs):\n                if i != j:\n                    n = min(capacities[j], state[i] + state[j])\n                    new_state = list(state)\n                    new_state[i], new_state[j] = state[i] + state[j] - n, n\n                    new_state = tuple(new_state)\n                    if new_state not in trails:\n                        queue.append(new_state)\n                        trails[new_state] = ([i, j], state)\n    ans = []\n    state = target\n    while state != start:\n        move, state = trails[state]\n        ans.append(move)\n    return ans[::-1]"], "module": "classic_puzzles.py", "notes": "[Water pouring puzzle](https://en.wikipedia.org/w/index.php?title=Water_pouring_puzzle&oldid=985741928)", "weight": 1.0}, {"name": "VerbalArithmetic:2", "sat": "def sat(li: List[int], words=['GREEN', 'ORANGE', 'COLORS']):\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]", "ans_type": "List[int]", "sol_header": "def sol(words=['GREEN', 'ORANGE', 'COLORS']):", "sol_docstring": "    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"", "sol_bodies": ["    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"], "module": "classic_puzzles.py", "notes": "Find a substitution of digits for characters to make the numbers add up in a sum like this:\nSEND + MORE = MONEY\n\nThe first digit in any number cannot be 0. In this example the solution is `9567 + 1085 = 10652`.\nSee [Wikipedia article](https://en.wikipedia.org/wiki/Verbal_arithmetic)", "weight": 1.0}, {"name": "Abbreviate:1", "sat": "def sat(s: str, word=\"pawuzorythalirinasubyg\", max_len=12):\n    if len(word) <= max_len:\n        return word == s\n    return int(s[1:-1]) == len(word[1:-1]) and word[0] == s[0] and word[-1] == s[-1]", "ans_type": "str", "sol_header": "def sol(word=\"pawuzorythalirinasubyg\", max_len=12):", "sol_docstring": "    \"\"\"\n    Abbreviate strings longer than a given length by replacing everything but the first and last characters by\n    an integer indicating how many characters there were in between them.\n    \"\"\"", "sol_bodies": ["    if len(word) <= max_len:\n        return word\n    return f\"{word[0]}{len(word) - 2}{word[-1]}\""], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 71 A](https://codeforces.com/problemset/problem/71/A)", "weight": 1.0}, {"name": "SquareTiles:4", "sat": "def sat(corners: List[List[int]], m=74, n=1, a=2, target=38):\n    covered = {(i + x, j + y) for i, j in corners for x in range(a) for y in range(a)}\n    assert len(covered) == len(corners) * a * a, \"Double coverage\"\n    return len(corners) <= target and covered.issuperset({(x, y) for x in range(m) for y in range(n)})", "ans_type": "List[List[int]]", "sol_header": "def sol(a=2, m=74, n=1, target=38):", "sol_docstring": "    \"\"\"Find a minimal list of corner locations for a\u00d7a tiles that covers [0, m] \u00d7 [0, n] and does not double-cover\n    squares.\n\n    Sample Input:\n    m = 10\n    n = 9\n    a = 5\n    target = 4\n\n    Sample Output:\n    [[0, 0], [0, 5], [5, 0], [5, 5]]\n    \"\"\"", "sol_bodies": ["    return [[x, y] for x in range(0, m, a) for y in range(0, n, a)]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 1 A](https://codeforces.com/problemset/problem/1/A)", "weight": 1.0}, {"name": "EasyTwos:3", "sat": "def sat(lb: List[bool], trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):\n    return len(lb) == len(trips) and all(\n        (b is True) if sum(s) >= 2 else (b is False) for b, s in zip(lb, trips))", "ans_type": "List[bool]", "sol_header": "def sol(trips=[[0, 0, 0], [0, 0, 1], [0, 1, 1], [1, 1, 1], [1, 1, 0], [0, 1, 1], [1, 0, 0], [0, 0, 0], [1, 0, 1], [1, 1, 0], [0, 0, 1], [1, 0, 1]]):", "sol_docstring": "    \"\"\"\n    Given a list of lists of triples of integers, return True for each list with a total of at least 2 and\n    False for each other list.\n    \"\"\"", "sol_bodies": ["    return [sum(s) >= 2 for s in trips]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 231 A](https://codeforces.com/problemset/problem/231/A)", "weight": 1.0}, {"name": "DecreasingCountComparison:0", "sat": "def sat(n: int, scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])", "ans_type": "int", "sol_header": "def sol(scores=[100, 95, 80, 70, 65, 9, 9, 9, 4, 2, 1], k=6):", "sol_docstring": "    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"", "sol_bodies": ["    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 158 A](https://codeforces.com/problemset/problem/158/A)", "weight": 1.0}, {"name": "VowelDrop:2", "sat": "def sat(t: str, s=\"kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL\"):\n    i = 0\n    for c in s.lower():\n        if c in \"aeiouy\":\n            continue\n        assert t[i] == \".\", f\"expecting `.` at position {i}\"\n        i += 1\n        assert t[i] == c, f\"expecting `{c}`\"\n        i += 1\n    return i == len(t)", "ans_type": "str", "sol_header": "def sol(s=\"kAgIHAdiHEKoNAJubozUKaMYDETAdeZyziveL\"):", "sol_docstring": "    \"\"\"\n    Given an alphabetic string s, remove all vowels (aeiouy/AEIOUY), insert a \".\" before each remaining letter\n    (consonant), and make everything lowercase.\n\n    Sample Input:\n    s = \"Problems\"\n\n    Sample Output:\n    .p.r.b.l.m.s\n    \"\"\"", "sol_bodies": ["    return \"\".join(\".\" + c for c in s.lower() if c not in \"aeiouy\")"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 118 A](https://codeforces.com/problemset/problem/118/A)", "weight": 1.0}, {"name": "DominoTile:3", "sat": "def sat(squares: List[List[int]], m=35, n=46, target=1610):\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target", "ans_type": "List[List[int]]", "sol_header": "def sol(m=35, n=46, target=1610):", "sol_docstring": "    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"", "sol_bodies": ["    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 50 A](https://codeforces.com/problemset/problem/50/A)", "weight": 1.0}, {"name": "IncDec:3", "sat": "def sat(n: int, ops=['--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++'], target=82823):\n    for op in ops:\n        if op in [\"++x\", \"x++\"]:\n            n += 1\n        else:\n            assert op in [\"--x\", \"x--\"]\n            n -= 1\n    return n == target", "ans_type": "int", "sol_header": "def sol(ops=['--x', 'x--', 'x--', 'x--', 'x--', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '--x', '--x', '--x', 'x--', '--x', '--x', '++x', '++x', '++x', 'x++', '--x', 'x--', '++x', 'x--', 'x--', 'x++', 'x--', 'x++', 'x++', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x--', '--x', 'x--', 'x++', 'x--', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '++x', '++x', 'x++', 'x++', 'x--', '--x', 'x++', 'x++', 'x--', 'x++', '--x', 'x--', 'x--', '++x', '++x', '++x', 'x++', '++x', '--x', '--x', 'x++', '++x', '++x', 'x++', '++x', '--x', '++x', '--x', 'x--', '++x', '++x', '++x', '++x', 'x--', 'x--', '++x', '++x', 'x--', 'x--', '++x', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', 'x--', '++x', 'x--', 'x--', 'x--', '++x', 'x--', '++x', 'x++', 'x--', 'x++', '++x', 'x++', '--x', '--x', '--x', 'x++', 'x++', '--x', '--x', '++x', '--x', 'x--', 'x--', '--x', 'x--', '++x', 'x--', '--x', '--x', '++x', '--x', 'x++', 'x--', 'x++', '--x', '--x', '++x', '--x', 'x--', '--x', 'x++', '--x', 'x--', '--x', '++x', 'x--', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x++', '++x', '++x', 'x++', '++x', 'x++', 'x--', 'x--', 'x--', '++x', '--x', '--x', '--x', '++x', 'x--', 'x--', '++x', 'x++', '++x', 'x--', '--x', '--x', '++x', 'x--', 'x--', '--x', 'x--', 'x--', 'x++', '--x', 'x++', '++x', '--x', 'x--', '--x', '--x', 'x--', 'x--', '--x', '++x', 'x--', '++x', '++x', '++x', 'x--', 'x--', '--x', '++x', 'x++', 'x--', 'x--', 'x++', '--x', 'x--', 'x++', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x++', '--x', 'x++', 'x--', '--x', 'x++', 'x++', '++x', '--x', '++x', 'x++', 'x--', 'x++', 'x--', 'x--', 'x--', 'x++', 'x++', '--x', '--x', 'x--', 'x++', '++x', 'x--', '--x', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '++x', 'x--', 'x++', 'x++', 'x++', '++x', '++x', '--x', 'x++', '--x', '--x', 'x--', '--x', 'x++', 'x--', 'x++', '--x', 'x--', 'x++', 'x++', 'x--', '--x', '--x', 'x++', '--x', 'x--', 'x++', 'x++', '++x', 'x--', '++x', '++x', 'x++', 'x--', '--x', '++x', '--x', 'x--', '--x', '++x', '--x', '--x', '++x', 'x++', '--x', 'x++', '--x', 'x--', '++x', '--x', 'x--', 'x--', 'x++', '++x', 'x++', '++x', 'x--', '--x', 'x++', '--x', '++x', 'x++', 'x++', 'x++', '++x', '++x', 'x++', '++x', '++x', '++x', 'x--', '++x', 'x--', 'x--', 'x++', '--x', '++x', 'x++', 'x++', 'x--', '++x', '++x', 'x--', 'x--', '--x', 'x--', '--x', 'x--', 'x--', '++x', '++x', 'x--', '--x', 'x++', '--x', '--x', 'x++', 'x++', 'x++', 'x++', '++x', '--x', 'x++', 'x++', '--x', '++x', 'x++', '--x', '--x', 'x--', '--x', 'x++'], target=82823):", "sol_docstring": "    \"\"\"\n    Given a sequence of operations \"++x\", \"x++\", \"--x\", \"x--\", and a target value, find initial value so that the\n    final value is the target value.\n\n    Sample Input:\n    ops = [\"x++\", \"--x\", \"--x\"]\n    target = 12\n\n    Sample Output:\n    13\n    \"\"\"", "sol_bodies": ["    return target - ops.count(\"++x\") - ops.count(\"x++\") + ops.count(\"--x\") + ops.count(\"x--\")"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 282 A](https://codeforces.com/problemset/problem/282/A)\n\nThis straightforward problem is a little harder than the Codeforces one.", "weight": 1.0}, {"name": "CompareInAnyCase:2", "sat": "def sat(n: int, s=\"tExTYtOHahekomArof\", t=\"TExTYTohaHeKomryGUSeteXTUrYgir\"):\n    if n == 0:\n        return s.lower() == t.lower()\n    if n == 1:\n        return s.lower() > t.lower()\n    if n == -1:\n        return s.lower() < t.lower()\n    return False", "ans_type": "int", "sol_header": "def sol(s=\"tExTYtOHahekomArof\", t=\"TExTYTohaHeKomryGUSeteXTUrYgir\"):", "sol_docstring": "    \"\"\"Ignoring case, compare s, t lexicographically. Output 0 if they are =, -1 if s < t, 1 if s > t.\"\"\"", "sol_bodies": ["    if s.lower() == t.lower():\n        return 0\n    if s.lower() > t.lower():\n        return 1\n    return -1"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 112 A](https://codeforces.com/problemset/problem/112/A)", "weight": 1.0}, {"name": "CapitalizeFirstLetter:2", "sat": "def sat(s: str, word=\"silon\"):\n    for i in range(len(word)):\n        if i == 0:\n            if s[i] != word[i].upper():\n                return False\n        else:\n            if s[i] != word[i]:\n                return False\n    return True", "ans_type": "str", "sol_header": "def sol(word=\"silon\"):", "sol_docstring": "    \"\"\"Capitalize the first letter of word\"\"\"", "sol_bodies": ["    return word[0].upper() + word[1:]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 281 A](https://codeforces.com/problemset/problem/281/A)", "weight": 1.0}, {"name": "LongestSubsetString:3", "sat": "def sat(t: str, s=\"c\", target=1):\n    i = 0\n    for c in t:\n        while c != s[i]:\n            i += 1\n        i += 1\n    return len(t) >= target and all(t[i] != t[i + 1] for i in range(len(t) - 1))", "ans_type": "str", "sol_header": "def sol(s=\"c\", target=1):", "sol_docstring": "    \"\"\"\n    You are given a string consisting of a's, b's and c's, find any longest substring containing no repeated\n    consecutive characters.\n\n    Sample Input:\n    `\"abbbc\"`\n\n    Sample Output:\n    `\"abc\"`\n    \"\"\"", "sol_bodies": ["    # target is ignored\n    return s[:1] + \"\".join([b for a, b in zip(s, s[1:]) if b != a])"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 266 A](https://codeforces.com/problemset/problem/266/A)", "weight": 1.0}, {"name": "Triple0:3", "sat": "def sat(delta: List[int], nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):\n    return all(sum(vec[i] for vec in nums) + delta[i] == 0 for i in range(3))", "ans_type": "List[int]", "sol_header": "def sol(nums=[[35, -53, 59], [78, -51, 93], [-20, -17, -17], [64, 46, -24], [-81, -100, 47], [-98, -21, 47], [48, -85, -55], [-82, -29, 65]]):", "sol_docstring": "    \"\"\"Find the missing triple of integers to make them all add up to 0 coordinatewise\"\"\"", "sol_bodies": ["    return [-sum(vec[i] for vec in nums) for i in range(3)]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 630 A](https://codeforces.com/problemset/problem/69/A)", "weight": 1.0}, {"name": "TotalDifference:2", "sat": "def sat(n: int, a=14, b=50, c=47):\n    return n + a == sum([b * i for i in range(c)])", "ans_type": "int", "sol_header": "def sol(a=14, b=50, c=47):", "sol_docstring": "    \"\"\"Find n such that n + a == b * (the sum of the first c integers)\"\"\"", "sol_bodies": ["    return -a + sum([b * i for i in range(c)])"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 546 A](https://codeforces.com/problemset/problem/546/A)", "weight": 1.0}, {"name": "TripleDouble:2", "sat": "def sat(n: int, v=609909721, w=872375011):\n    for i in range(n):\n        assert v <= w\n        v *= 3\n        w *= 2\n    return v > w", "ans_type": "int", "sol_header": "def sol(v=609909721, w=872375011):", "sol_docstring": "    \"\"\"Find the smallest n such that if v is tripled n times and w is doubled n times, v exceeds w.\"\"\"", "sol_bodies": ["    i = 0\n    while v <= w:\n        v *= 3\n        w *= 2\n        i += 1\n    return i"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 791 A](https://codeforces.com/problemset/problem/791/A)", "weight": 1.0}, {"name": "RepeatDec:2", "sat": "def sat(res: int, m=22262059435814874058, n=6):\n    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return res == m", "ans_type": "int", "sol_header": "def sol(m=22262059435814874058, n=6):", "sol_docstring": "    \"\"\"\n    Find the result of applying the following operation to integer m, n times: if the last digit is zero, remove\n    the zero, otherwise subtract 1.\n    \"\"\"", "sol_bodies": ["    for i in range(n):\n        m = (m - 1 if m % 10 else m // 10)\n    return m"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 977 A](https://codeforces.com/problemset/problem/977/A)", "weight": 1.0}, {"name": "MaxDelta:2", "sat": "def sat(n: int, pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success", "ans_type": "int", "sol_header": "def sol(pairs=[[266519, 0], [548032, 32788], [612482, 632311], [465240, 376403], [123288, 475698], [962873, 439482], [193531, 258475], [747616, 319130], [592192, 824307], [508933, 296745], [411467, 566648], [905981, 19854], [805465, 657818], [802088, 325540], [127441, 1703553], [19150, 964316], [0, 199230]]):", "sol_docstring": "    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"", "sol_bodies": ["    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 116 A](https://codeforces.com/problemset/problem/116/A)", "weight": 1.0}, {"name": "CommonCase:4", "sat": "def sat(s_case: str, s=\"rAC\"):\n    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return s_case == (s.upper() if caps > len(s) // 2 else s.lower())", "ans_type": "str", "sol_header": "def sol(s=\"rAC\"):", "sol_docstring": "    \"\"\"\n    Given a word, replace it either with an upper-case or lower-case depending on whether or not it has more\n    capitals or lower-case letters. If it has strictly more capitals, use upper-case, otherwise, use lower-case.\n    \"\"\"", "sol_bodies": ["    caps = 0\n    for c in s:\n        if c != c.lower():\n            caps += 1\n    return (s.upper() if caps > len(s) // 2 else s.lower())  # duh, just take sat and return the answer checked for"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 59 A](https://codeforces.com/problemset/problem/59/A)\n\nThis is a trivial puzzle, especially if the AI realizes that it can can just copy the solution from\nthe problem", "weight": 1.0}, {"name": "Sstriiinggssuubb:2", "sat": "def sat(inds: List[int], string=\"gteliikeenGgqIHent\"):\n    return inds == sorted(inds) and \"\".join(string[i] for i in inds) == \"intelligent\"", "ans_type": "List[int]", "sol_header": "def sol(string=\"gteliikeenGgqIHent\"):", "sol_docstring": "    \"\"\"Find increasing indices to make the substring \"intelligent\" (with a surprise twist)\"\"\"", "sol_bodies": ["    target = \"intelligent\"\n    j = 0\n    ans = []\n    for i in range(-len(string), len(string)):\n        while string[i] == target[j]:\n            ans.append(i)\n            j += 1\n            if j == len(target):\n                return ans"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 58 A](https://codeforces.com/problemset/problem/58/A)", "weight": 1.0}, {"name": "Count47:4", "sat": "def sat(d: int, n=707):\n    return d > n and all(i in \"47\" for i in str(str(d).count(\"4\") + str(d).count(\"7\")))", "ans_type": "int", "sol_header": "def sol(n=707):", "sol_docstring": "    \"\"\"\n    Find a number bigger than n whose decimal representation has k 4's and 7's where k's decimal representation\n    consists only of 4's and 7's\n    \"\"\"", "sol_bodies": ["    return int(\"4444\" + \"0\" * (len(str(n)) - 3))"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 110 A](https://codeforces.com/problemset/problem/110/A)", "weight": 1.0}, {"name": "MaybeReversed:4", "sat": "def sat(s: str, target=\"rechawewivetextovy\", reverse=True):\n    return (s[::-1] == target) == reverse", "ans_type": "str", "sol_header": "def sol(target=\"rechawewivetextovy\", reverse=True):", "sol_docstring": "    \"\"\"Either reverse a string or don't based on the reverse flag\"\"\"", "sol_bodies": ["    return target[::-1] if reverse else target + \"x\""], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 41 A](https://codeforces.com/problemset/problem/41/A)", "weight": 1.0}, {"name": "Dada:4", "sat": "def sat(s: str, a=4763, d=8408):\n    return s.count(\"a\") == a and s.count(\"d\") == d and len(s) == a + d", "ans_type": "str", "sol_header": "def sol(a=4763, d=8408):", "sol_docstring": "    \"\"\"Find a string with a given number of a's and d's\"\"\"", "sol_bodies": ["    return \"a\" * a + \"d\" * d"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 734 A](https://codeforces.com/problemset/problem/734/A)", "weight": 1.0}, {"name": "DistinctDigits:4", "sat": "def sat(nums: List[int], a=136, b=176, count=34):\n    assert all(len(str(n)) == len(set(str(n))) and a <= n <= b for n in nums)\n    return len(set(nums)) >= count", "ans_type": "List[int]", "sol_header": "def sol(a=136, b=176, count=34):", "sol_docstring": "    \"\"\"Find a list of count or more different numbers each between a and b that each have no repeated digits\"\"\"", "sol_bodies": ["    return [n for n in range(a, b + 1) if len(str(n)) == len(set(str(n)))]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 271 A](https://codeforces.com/problemset/problem/271/A)", "weight": 1.0}, {"name": "EasySum:0", "sat": "def sat(tot: int, nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):\n    return tot == sum(1 if i < thresh else 2 for i in nums)", "ans_type": "int", "sol_header": "def sol(nums=[2, 8, 25, 18, 99, 11, 17, 16], thresh=17):", "sol_docstring": "    \"\"\"Add up 1 or 2 for numbers in a list depending on whether they exceed a threshold\"\"\"", "sol_bodies": ["    return sum(1 if i < thresh else 2 for i in nums)"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 677 A](https://codeforces.com/problemset/problem/677/A)", "weight": 1.0}, {"name": "GimmeChars:2", "sat": "def sat(s: str, chars=['[', '/', 'g']):\n    for c in chars:\n        if c not in s:\n            return False\n    return True", "ans_type": "str", "sol_header": "def sol(chars=['[', '/', 'g']):", "sol_docstring": "    \"\"\"Find a string with certain characters\"\"\"", "sol_bodies": [], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 133 A](https://codeforces.com/problemset/problem/133/A), easy", "weight": 1.0}, {"name": "HalfPairs:0", "sat": "def sat(ans: List[List[int]], target=17):\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0", "ans_type": "List[List[int]]", "sol_header": "def sol(target=17):", "sol_docstring": "    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"", "sol_bodies": ["    return [[0, 2]] * target"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 467 A](https://codeforces.com/problemset/problem/467/A)", "weight": 1.0}, {"name": "InvertIndices:1", "sat": "def sat(indexes: List[int], target=[16, 12, 67, 77, 23, 47, 24, 45, 61, 80, 43, 50, 57, 81, 21, 55, 9, 28, 14, 87, 58, 35, 37, 63, 41, 38, 6, 86, 59, 13, 49, 68, 83, 30, 40, 73, 15, 11, 85, 70, 33, 22, 76, 5, 82, 52, 27, 26, 34, 89, 1, 48, 64, 88, 19, 29, 65, 69, 31, 2, 74, 32, 60, 7, 46, 56, 78, 79, 36, 51, 72, 71, 54, 20, 90, 8, 53, 75, 39, 4, 17, 62, 25, 3, 84, 42, 44, 10, 66, 18]):\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True", "ans_type": "List[int]", "sol_header": "def sol(target=[16, 12, 67, 77, 23, 47, 24, 45, 61, 80, 43, 50, 57, 81, 21, 55, 9, 28, 14, 87, 58, 35, 37, 63, 41, 38, 6, 86, 59, 13, 49, 68, 83, 30, 40, 73, 15, 11, 85, 70, 33, 22, 76, 5, 82, 52, 27, 26, 34, 89, 1, 48, 64, 88, 19, 29, 65, 69, 31, 2, 74, 32, 60, 7, 46, 56, 78, 79, 36, 51, 72, 71, 54, 20, 90, 8, 53, 75, 39, 4, 17, 62, 25, 3, 84, 42, 44, 10, 66, 18]):", "sol_docstring": "    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"", "sol_bodies": [], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 136 A](https://codeforces.com/problemset/problem/136/A)", "weight": 1.0}, {"name": "FivePowers:3", "sat": "def sat(s: str, n=2):\n    return int(str(5 ** n)[:-2] + s) == 5 ** n", "ans_type": "str", "sol_header": "def sol(n=2):", "sol_docstring": "    \"\"\"What are the last two digits of 5^n?\"\"\"", "sol_bodies": ["    return (\"1\" if n == 0 else \"5\" if n == 1 else \"25\")"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 630 A](https://codeforces.com/problemset/problem/630/A)", "weight": 1.0}, {"name": "CombinationLock:0", "sat": "def sat(states: List[str], start=\"424\", combo=\"778\", target_len=12):\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len", "ans_type": "List[str]", "sol_header": "def sol(start=\"424\", combo=\"778\", target_len=12):", "sol_docstring": "    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"", "sol_bodies": ["    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 540 A](https://codeforces.com/problemset/problem/540/A)", "weight": 1.0}, {"name": "CombinationLockObfuscated:3", "sat": "def sat(states: List[str], start=\"4\", combo=\"3\", target_len=0):\n    return all(sum((int(a[i]) - int(b[i])) ** 2 % 10 for i in range(len(start))) == 1\n               for a, b in zip([start] + states, states[:target_len] + [combo]))", "ans_type": "List[str]", "sol_header": "def sol(start=\"4\", combo=\"3\", target_len=0):", "sol_docstring": "    \"\"\"Figure out what this does only from the code\"\"\"", "sol_bodies": ["    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 540 A](https://codeforces.com/problemset/problem/540/A)\nThis an obfuscated version of CombinationLock above, can the AI figure out what is being asked or that\nit is the same puzzle?", "weight": 1.0}, {"name": "InvertPermutation:2", "sat": "def sat(s: str, perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"mujychenyzo\"):\n    return \"\".join((perm[(perm.index(c) + 1) % len(perm)] if c in perm else c) for c in s) == target", "ans_type": "str", "sol_header": "def sol(perm=\"qwertyuiopasdfghjklzxcvbnm\", target=\"mujychenyzo\"):", "sol_docstring": "    \"\"\"Find a string that, when a given permutation of characters is applied, has a given result.\"\"\"", "sol_bodies": ["    return \"\".join((perm[(perm.index(c) - 1) % len(perm)] if c in perm else c) for c in target)"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 474 A](https://codeforces.com/problemset/problem/474/A)", "weight": 1.0}, {"name": "SameDifferent:0", "sat": "def sat(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True", "ans_type": "List[List[int]]", "sol_header": "def sol(items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):", "sol_docstring": "    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"", "sol_bodies": ["    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 1335 C](https://codeforces.com/problemset/problem/1335/C)", "weight": 1.0}, {"name": "OnesAndTwos:0", "sat": "def sat(seq: List[int], n=10000, length=5017):\n    return all(i in [1, 2] for i in seq) and sum(seq) == n and len(seq) == length", "ans_type": "List[int]", "sol_header": "def sol(n=10000, length=5017):", "sol_docstring": "    \"\"\"Find a sequence of 1's and 2's of a given length that that adds up to n\"\"\"", "sol_bodies": ["    return [2] * (n - length) + [1] * (2 * length - n)"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 476 A](https://codeforces.com/problemset/problem/476/A)", "weight": 1.0}, {"name": "MinConsecutiveSum:1", "sat": "def sat(start: int, k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) <= upper", "ans_type": "int", "sol_header": "def sol(k=2, upper=-172, seq=[79, 18, -98, -13, 88, -93, -77, -95, 40, -3, -22]):", "sol_docstring": "    \"\"\"Find a sequence of k consecutive indices whose sum is minimal\"\"\"", "sol_bodies": ["    return min(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)", "weight": 1.0}, {"name": "MaxConsecutiveSum:0", "sat": "def sat(start: int, k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):\n    return 0 <= start <= len(seq) - k and sum(seq[start:start + k]) >= lower", "ans_type": "int", "sol_header": "def sol(k=3, lower=150, seq=[3, 1, 2, 65, 18, 91, -30, 100, 0, 19, 52]):", "sol_docstring": "    \"\"\"Find a sequence of k consecutive indices whose sum is maximal\"\"\"", "sol_bodies": ["    return max(range(len(seq) - k + 1), key=lambda start: sum(seq[start:start + k]))"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)", "weight": 1.0}, {"name": "MaxConsecutiveProduct:4", "sat": "def sat(start: int, k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):\n    prod = 1\n    for i in range(start, start + k):\n        prod *= seq[i]\n    return prod >= lower", "ans_type": "int", "sol_header": "def sol(k=10, lower=-8326797433194240, seq=[49, -99, 80, 26, 54, 13, 37, 13, -52, -47]):", "sol_docstring": "    \"\"\"Find a sequence of k consecutive indices whose product is maximal, possibly looping around\"\"\"", "sol_bodies": ["    def prod(start):\n        ans = 1\n        for i in range(start, start + k):\n            ans *= seq[i]\n        return ans\n\n    return max(range(-len(seq), len(seq) - k + 1), key=prod)"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 363 B](https://codeforces.com/problemset/problem/363/B)", "weight": 1.0}, {"name": "DistinctOddSum:3", "sat": "def sat(nums: List[int], tot=5359, n=11):\n    return len(nums) == len(set(nums)) == n and sum(nums) == tot and all(i >= i % 2 > 0 for i in nums)", "ans_type": "List[int]", "sol_header": "def sol(tot=5359, n=11):", "sol_docstring": "    \"\"\"Find n distinct positive odd integers that sum to tot\"\"\"", "sol_bodies": ["    return list(range(1, 2 * n - 1, 2)) + [tot - sum(range(1, 2 * n - 1, 2))]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 1327 A](https://codeforces.com/problemset/problem/1327/A)", "weight": 1.0}, {"name": "MinRotations:0", "sat": "def sat(rotations: List[int], target=\"wonderful\", upper=69):\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    assert len(rotations) == len(target)\n    for r, c in zip(rotations, target):\n        s = s[r:] + s[:r]\n        assert s[0] == c\n\n    return sum(abs(r) for r in rotations) <= upper", "ans_type": "List[int]", "sol_header": "def sol(target=\"wonderful\", upper=69):", "sol_docstring": "    \"\"\"\n    We begin with the string `\"a...z\"`\n\n    An `r`-rotation of a string means shifting it to the right (positive) or left (negative) by `r` characters and\n    cycling around. Given a target string of length n, find the n rotations that put the consecutive characters\n    of that string at the beginning of the r-rotation, with minimal sum of absolute values of the `r`'s.\n\n    For example if the string was `'dad'`, the minimal rotations would be `[3, -3, 3]` with a total of `9`.\n    \"\"\"", "sol_bodies": ["    s = \"abcdefghijklmnopqrstuvwxyz\"\n    ans = []\n    for c in target:\n        i = s.index(c)\n        r = min([i, i - len(s)], key=abs)\n        ans.append(r)\n        s = s[r:] + s[:r]\n        assert s[0] == c\n    return ans"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 731 A](https://codeforces.com/problemset/problem/731/A)", "weight": 1.0}, {"name": "BillSums:2", "sat": "def sat(bills: List[int], denominations=[1, 44, 69], n=727, max_len=18):\n    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len", "ans_type": "List[int]", "sol_header": "def sol(denominations=[1, 44, 69], n=727, max_len=18):", "sol_docstring": "    \"\"\"\n    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations\n    \"\"\"", "sol_bodies": ["    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 996 A](https://codeforces.com/problemset/problem/996/A)\n\nWe make it much harder when the denominations are non-American so the greedy algorithm doesn't work.", "weight": 1.0}, {"name": "BoxVolume:0", "sat": "def sat(sides: List[int], options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13):\n    prod = 1\n    for b in sides:\n        prod *= b\n    return prod == n and set(sides) <= set(options) and len(sides) <= max_dim", "ans_type": "List[int]", "sol_header": "def sol(options=[2, 512, 1024], n=340282366920938463463374607431768211456, max_dim=13):", "sol_docstring": "    \"\"\"\n    Find the side lengths of a box in fewest dimensions (dimension <= max_dim) whose volume is n,\n     where each side length is in options\n    \"\"\"", "sol_bodies": ["    options = sorted(set(options))\n    base = options[0]\n    logs = []\n    for i in options + [n]:\n        j = 1\n        log = 0\n        while j < i:\n            log +=1\n            j *= base\n        assert j == i, \"All numbers must be a power of the smallest number\"\n        logs.append(log)\n    denominations, n = logs[:-1], logs[-1]\n\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [base ** k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]"], "module": "codeforces.py", "notes": "(Also) inspired by [Codeforces Problem 996 A](https://codeforces.com/problemset/problem/996/A)\n\nWe make it much much harder by making it a multiplication problem where the greedy algorithm doesn't work.", "weight": 1.0}, {"name": "QuadraticRoot:1", "sat": "def sat(x: float, coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):\n    a, b, c = coeffs\n    return abs(a * x ** 2 + b * x + c) < 1e-6", "ans_type": "float", "sol_header": "def sol(coeffs=[0.0685642998539026, -0.10446230957339113, -0.11141402891228723]):", "sol_docstring": "    \"\"\"\n    Find any (real) solution to:  a x^2 + b x + c where coeffs = [a, b, c].\n    For example, since x^2 - 3x + 2 has a root at 1, sat(x = 1., coeffs = [1., -3., 2.]) is True.\n    \"\"\"", "sol_bodies": ["    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = ((-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a))\n    return ans", "    a, b, c = coeffs\n    if a == 0:\n        ans = -c / b if b != 0 else 0.0\n    else:\n        ans = (-b - (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)\n    return ans"], "module": "algebra.py", "notes": "See [quadratic equations](https://en.wikipedia.org/wiki/Quadratic_formula)", "weight": 1.0}, {"name": "AllQuadraticRoots:4", "sat": "def sat(roots: List[float], coeffs=[9.155105839032705, -0.9467446341738642]):\n    b, c = coeffs\n    r1, r2 = roots\n    return abs(r1 + r2 + b) + abs(r1 * r2 - c) < 1e-6", "ans_type": "List[float]", "sol_header": "def sol(coeffs=[9.155105839032705, -0.9467446341738642]):", "sol_docstring": "    \"\"\"Find all (real) solutions to: x^2 + b x + c (i.e., factor into roots), here coeffs = [b, c]\"\"\"", "sol_bodies": ["    b, c = coeffs\n    delta = (b ** 2 - 4 * c) ** 0.5\n    return [(-b + delta) / 2, (-b - delta) / 2]"], "module": "algebra.py", "notes": "See [quadratic equations](https://en.wikipedia.org/wiki/Quadratic_formula).", "weight": 1.0}, {"name": "SumOfDigits:3", "sat": "def sat(x: str, s=86120):\n    return s == sum([int(d) for d in x])", "ans_type": "str", "sol_header": "def sol(s=86120):", "sol_docstring": "    \"\"\"Find a number that its digits sum to a specific value.\"\"\"", "sol_bodies": ["    return int(s / 9) * '9' + str(s % 9)"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "FloatWithDecimalValue:0", "sat": "def sat(z: float, v=9, d=0.0001):\n    return int(z * 1 / d % 10) == v", "ans_type": "float", "sol_header": "def sol(v=9, d=0.0001):", "sol_docstring": "    \"\"\"Create a float with a specific decimal.\"\"\"", "sol_bodies": ["    return v * d"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "ArithmeticSequence:1", "sat": "def sat(x: List[int], a=43536, s=3795, e=417606):\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])", "ans_type": "List[int]", "sol_header": "def sol(a=43536, e=417606, s=3795):", "sol_docstring": "    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"", "sol_bodies": ["    return list(range(a, e + 1, s))"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "LineIntersection:0", "sat": "def sat(e: List[int], a=2, b=-1, c=1, d=2021):\n    x = e[0] / e[1]\n    return abs(a * x + b - c * x - d) < 10 ** -5", "ans_type": "List[int]", "sol_header": "def sol(a=2, b=-1, c=1, d=2021):", "sol_docstring": "    \"\"\"\n    Find the intersection of two lines.\n    Solution should be a list of the (x,y) coordinates.\n    Accuracy of fifth decimal digit is required.\n    \"\"\"", "sol_bodies": ["    return [d - b, a - c]"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "IfProblemWithOr:1", "sat": "def sat(x: int, a=22, b=-84904666):\n    if x > 0 or a > 50:\n        return x - a == b\n    else:\n        return x + a == b", "ans_type": "int", "sol_header": "def sol(a=22, b=-84904666):", "sol_docstring": "    \"\"\"Satisfy a simple if statement with an or clause\"\"\"", "sol_bodies": ["    if a > 50 or b > a:\n        return b + a\n    else:\n        return b - a"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "IfCases:2", "sat": "def sat(x: int, a=-3, b=71965664):\n    if a == 1:\n        return x % 2 == 0\n    elif a == -1:\n        return x % 2 == 1\n    else:\n        return x + a == b", "ans_type": "int", "sol_header": "def sol(a=-3, b=71965664):", "sol_docstring": "    \"\"\"Satisfy a simple if statement with multiple cases\"\"\"", "sol_bodies": ["    if a == 1:\n        x = 0\n    elif a == -1:\n        x = 1\n    else:\n        x = b - a\n    return x"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "ListPosSum:4", "sat": "def sat(x: List[int], n=9909, s=88140438):\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])", "ans_type": "List[int]", "sol_header": "def sol(n=9909, s=88140438):", "sol_docstring": "    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"", "sol_bodies": ["    x = [1] * n\n    x[0] = s - n + 1\n    return x"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "ListDistinctSum:4", "sat": "def sat(x: List[int], n=225, s=38417364):\n    return len(x) == n and sum(x) == s and len(set(x)) == n", "ans_type": "List[int]", "sol_header": "def sol(n=225, s=38417364):", "sol_docstring": "    \"\"\"Construct a list of n distinct integers that sum up to s\"\"\"", "sol_bodies": ["    a = 1\n    x = []\n    while len(x) < n - 1:\n        x.append(a)\n        a = -a\n        if a in x:\n            a += 1\n\n    if s - sum(x) in x:\n        x = [i for i in range(n - 1)]\n\n    x = x + [s - sum(x)]\n    return x"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "ConcatStrings:4", "sat": "def sat(x: str, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm'], n=16):\n    return len(x) == n and all([x[i] == s[i] for i in range(n)])", "ans_type": "str", "sol_header": "def sol(n=16, s=['0', '@', 'R', 'k', '$', '$', 't', '0', '3', '#', '!', 'a', 'w', 'k', 'q', 'H', '-', 'm']):", "sol_docstring": "    \"\"\"Concatenate the list of characters in s\"\"\"", "sol_bodies": ["    return ''.join([s[i] for i in range(n)])"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "SublistSum:1", "sat": "def sat(x: List[int], t=44475424, a=93, e=8496, s=6):\n    non_zero = [z for z in x if z != 0]\n    return t == sum([x[i] for i in range(a, e, s)]) and len(set(non_zero)) == len(non_zero) and all(\n        [x[i] != 0 for i in range(a, e, s)])", "ans_type": "List[int]", "sol_header": "def sol(t=44475424, a=93, e=8496, s=6):", "sol_docstring": "    \"\"\"Sum values of sublist by range specifications\"\"\"", "sol_bodies": ["    x = [0] * e\n    for i in range(a, e, s):\n        x[i] = i\n    correction = t - sum(x) + x[i]\n    if correction in x:\n        x[correction] = -1 * correction\n        x[i] = 3 * correction\n    else:\n        x[i] = correction\n    return x"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "CumulativeSum:1", "sat": "def sat(x: List[int], t=364928431, n=1088):\n    assert all([v > 0 for v in x])\n    s = 0\n    i = 0\n    for v in sorted(x):\n        s += v\n        if s > t:\n            return i == n\n        i += 1\n    return i == n", "ans_type": "List[int]", "sol_header": "def sol(t=364928431, n=1088):", "sol_docstring": "    \"\"\"Find how many values have cumulative sum less than target\"\"\"", "sol_bodies": ["    return [1] * n + [t]"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "BasicStrCounts:1", "sat": "def sat(s: str, s1=\"t\", s2=\"qu\", count1=86, count2=83):\n    return s.count(s1) == count1 and s.count(s2) == count2 and s[:10] == s[-10:]", "ans_type": "str", "sol_header": "def sol(s1=\"t\", s2=\"qu\", count1=86, count2=83):", "sol_docstring": "    \"\"\"\n    Find a string that has count1 occurrences of s1 and count2 occurrences of s2 and starts and ends with\n    the same 10 characters\n    \"\"\"", "sol_bodies": ["    if s1 == s2:\n        ans = (s1 + \"?\") * count1\n    elif s1.count(s2):\n        ans = (s1 + \"?\") * count1\n        ans += (s2 + \"?\") * (count2 - ans.count(s2))\n    else:\n        ans = (s2 + \"?\") * count2\n        ans += (s1 + \"?\") * (count1 - ans.count(s1))\n    return \"?\" * 10 + ans + \"?\" * 10"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "ZipStr:3", "sat": "def sat(s: str, substrings=['te', 'wusyc']):\n    return all(sub in s[i::len(substrings)] for i, sub in enumerate(substrings))", "ans_type": "str", "sol_header": "def sol(substrings=['te', 'wusyc']):", "sol_docstring": "    \"\"\"\n    Find a string that contains each string in substrings alternating, e.g., 'cdaotg' for 'cat' and 'dog'\n    \"\"\"", "sol_bodies": ["    m = max(len(s) for s in substrings)\n    return \"\".join([(s[i] if i < len(s) else \" \") for i in range(m) for s in substrings])"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "ReverseCat:0", "sat": "def sat(s: str, substrings=['foo', 'bar', 'baz']):\n    return all(sub in s and sub[::-1] in s for sub in substrings)", "ans_type": "str", "sol_header": "def sol(substrings=['foo', 'bar', 'baz']):", "sol_docstring": "    \"\"\"\n    Find a string that contains all the substrings reversed and forward\n    \"\"\"", "sol_bodies": ["    return \"\".join(substrings + [s[::-1] for s in substrings])"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "PenultimateString:0", "sat": "def sat(s: str, strings=['cat', 'dog', 'bird', 'fly', 'moose']):\n    return s in strings and sum(t > s for t in strings) == 1", "ans_type": "str", "sol_header": "def sol(strings=['cat', 'dog', 'bird', 'fly', 'moose']):", "sol_docstring": "    \"\"\"Find the alphabetically second to last last string in a list.\"\"\"", "sol_bodies": ["    return sorted(strings)[-2]"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "PenultimateRevString:2", "sat": "def sat(s: str, strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):\n    return s[::-1] in strings and sum(t < s[::-1] for t in strings) == 1", "ans_type": "str", "sol_header": "def sol(strings=['thythanaham', 'quiroxebadivogis', 'kyh', 'xa', 'gathytyjonymihahahy', 'musyzisequyxyhenico', 'poxizitizexokigewifi', 'mife', 'chyjuratexta', 'gyrato']):", "sol_docstring": "    \"\"\"Find the reversed version of the alphabetically second string in a list.\"\"\"", "sol_bodies": ["    return sorted(strings)[1][::-1]"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "CenteredString:0", "sat": "def sat(s: str, target=\"foobarbazwow\", length=6):\n    return target[(len(target) - length) // 2:(len(target) + length) // 2] == s", "ans_type": "str", "sol_header": "def sol(target=\"foobarbazwow\", length=6):", "sol_docstring": "    \"\"\"Find a substring of the given length centered within the target string.\"\"\"", "sol_bodies": ["    return target[(len(target) - length) // 2:(len(target) + length) // 2]"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "SubstrCount:3", "sat": "def sat(substring: str, string=\"cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf\", count=3):\n    return string.count(substring) == count", "ans_type": "str", "sol_header": "def sol(string=\"cutextolichymocajethamopyvepethytextydynykihywyxivytextequylejekuf\", count=3):", "sol_docstring": "    \"\"\"Find a substring with a certain count in a given string\"\"\"", "sol_bodies": ["    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            substring = string[i:j]\n            c = string.count(substring)\n            if c == count:\n                return substring\n            if c < count:\n                break\n    assert False"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "CompleteParens:4", "sat": "def sat(t: str, s=\"))())l\"):\n    for i in range(len(t) + 1):\n        depth = t[:i].count(\"(\") - t[:i].count(\")\")\n        assert depth >= 0\n    return depth == 0 and s in t", "ans_type": "str", "sol_header": "def sol(s=\"))())l\"):", "sol_docstring": "    \"\"\"Add parentheses to the beginning and end of s to make all parentheses balanced\"\"\"", "sol_bodies": ["    return \"(\" * s.count(\")\") + s + \")\" * s.count(\"(\")"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "EightQueensOrFewer:1", "sat": "def sat(squares: List[List[int]], m=9, n=6):\n    k = min(m, n)\n    assert all(i in range(m) and j in range(n) for i, j in squares) and len(squares) == k\n    return 4 * k == len({t for i, j in squares for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]})", "ans_type": "List[List[int]]", "sol_header": "def sol(m=9, n=6):", "sol_docstring": "    \"\"\"Position min(m, n) <= 8 queens on an m x n chess board so that no pair is attacking each other.\"\"\"", "sol_bodies": ["    # brute force\n    k = min(m, n)\n\n    from itertools import permutations\n    for p in permutations(range(k)):\n        if 4 * k == len(\n                {t for i, j in enumerate(p) for t in [('row', i), ('col', j), ('SE', i + j), ('NE', i - j)]}):\n            return [[i, j] for i, j in enumerate(p)]"], "module": "chess.py", "notes": "Eight (or fewer) Queens Puzzle\n\nSee Wikipedia entry on\n[Eight Queens puzzle](https://en.wikipedia.org/w/index.php?title=Eight_queens_puzzle).\n\nSee the MoreQueens puzzle below for another (longer but clearer) equivalent definition of sat\n\nHint: a brute force approach works on this puzzle.", "weight": 1.0}, {"name": "KnightsTour:4", "sat": "def sat(tour: List[List[int]], m=7, n=8):\n    assert all({abs(i1 - i2), abs(j1 - j2)} == {1, 2} for [i1, j1], [i2, j2] in zip(tour, tour[1:])), 'legal moves'\n    return sorted(tour) == [[i, j] for i in range(m) for j in range(n)]  # cover every square once", "ans_type": "List[List[int]]", "sol_header": "def sol(m=7, n=8):", "sol_docstring": "    \"\"\"Find an (open) tour of knight moves on an m x n chess-board that visits each square once.\"\"\"", "sol_bodies": ["    # using Warnsdorff's heuristic, breaking ties randomly\n    import random\n    for seed in range(100):\n        r = random.Random(seed)\n        ans = [(0, 0)]\n        free = {(i, j) for i in range(m) for j in range(n)} - {(0, 0)}\n\n        def possible(i, j):\n            moves = [(i + s * a, j + t * b) for (a, b) in [(1, 2), (2, 1)] for s in [-1, 1] for t in [-1, 1]]\n            return [z for z in moves if z in free]\n\n        while True:\n            if not free:\n                return [[a, b] for (a, b) in ans]\n            candidates = possible(*ans[-1])\n            if not candidates:\n                break\n            ans.append(min(candidates, key=lambda z: len(possible(*z)) + r.random()))\n            free.remove(ans[-1])"], "module": "chess.py", "notes": "See Wikipedia entry on [Knight's tour](https://en.wikipedia.org/w/index.php?title=Knight%27s_tour)", "weight": 1.0}, {"name": "UncrossedKnightsPath:0", "sat": "def sat(path: List[List[int]], m=8, n=8, target=35):\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target", "ans_type": "List[List[int]]", "sol_header": "def sol(m=8, n=8, target=35):", "sol_docstring": "    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"", "sol_bodies": [], "module": "chess.py", "notes": "Uncrossed Knights Path (known solvable, but no solution given)\n\nThe goal of these problems is to match the nxn_records from [http://ukt.alex-black.ru/](http://ukt.alex-black.ru/)\n(accessed 2020-11-29).\n\nA more precise description is in this\n[Wikipedia article](https://en.wikipedia.org/w/index.php?title=Longest_uncrossed_knight%27s_path).", "weight": 1.0}, {"name": "UNSOLVED_UncrossedKnightsPath:2", "sat": "def sat(path: List[List[int]], m=12, n=12, target=95):\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target", "ans_type": "List[List[int]]", "sol_header": "def sol(m=12, n=12, target=95):", "sol_docstring": "    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"", "sol_bodies": [], "module": "chess.py", "notes": "Uncrossed Knights Path (open problem, unsolved)\n\nSimilar to above, but the goal of these problems is to *beat* the nxn_records from\n[http://ukt.alex-black.ru/](http://ukt.alex-black.ru/)\n(accessed 2020-11-29).\n\nA more precise description is in this\n[Wikipedia article](https://en.wikipedia.org/w/index.php?title=Longest_uncrossed_knight%27s_path).", "weight": 1.0}, {"name": "ReverseLifeStep:2", "sat": "def sat(position: List[List[int]], target=[[-1, -4], [-1, -3], [0, -5], [0, -4], [1, -3]]):\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}", "ans_type": "List[List[int]]", "sol_header": "def sol(target=[[-1, -4], [-1, -3], [0, -5], [0, -4], [1, -3]]):", "sol_docstring": "    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"", "sol_bodies": ["    # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"], "module": "conways_game_of_life.py", "notes": "Unsolvable for \"Garden of Eden\" positions, but we only generate solvable examples", "weight": 1.0}, {"name": "Spaceship:0", "sat": "def sat(init: List[List[int]], period=4):\n    live = {x + y * 1j for x, y in init}  # use complex numbers\n    init_tot = sum(live)\n    target = {z * len(live) - init_tot for z in live}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    for t in range(period):\n        visible = {z + d for z in live for d in deltas}\n        live = {z for z in visible if 3 - (z in live) <= sum(z + d in live for d in deltas) <= 3}\n        tot = sum(live)\n        if {z * len(live) - tot for z in live} == target:\n            return t + 1 == period and tot != init_tot", "ans_type": "List[List[int]]", "sol_header": "def sol(period=4):", "sol_docstring": "    \"\"\"\n    Find a \"spaceship\" (see https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29 ) in Conway's\n    Game of Life see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life with a certain period\n    \"\"\"", "sol_bodies": [], "module": "conways_game_of_life.py", "notes": "Spaceship (including *unsolved*, open problems)\n\nFind a [spaceship](https://en.wikipedia.org/wiki/Spaceship_%28cellular_automaton%29) in\n[Conway's Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)\nwith a certain period.\n\nThis is an *unsolved* problem for periods 33, 34.", "weight": 1.0}, {"name": "Nim:3", "sat": "def sat(moves: List[List[int]], initial_state=[3, 3, 2, 2, 3, 8]):\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    state = initial_state[:]  # copy\n    for i, n in moves:\n        assert 0 < n <= state[i], \"Illegal move\"\n        state[i] -= n\n        if set(state) == {0}:\n            return True  # you won!\n        assert any(state), \"You lost!\"\n        bot_move()", "ans_type": "List[List[int]]", "sol_header": "def sol(initial_state=[3, 3, 2, 2, 3, 8]):", "sol_docstring": "    \"\"\"\n    Beat a bot at Nim, a two-player game involving a number of heaps of objects. Players alternate, in each turn\n    removing one or more objects from a single non-empty heap. The player who takes the last object wins.\n    - initial_state is list of numbers of objects in each heap\n    - moves is a list of your moves: [heap, number of objects to take]\n    - you play first\n    \"\"\"", "sol_bodies": ["\n    state = initial_state[:]\n    moves = []\n\n    def bot_move():  # bot takes objects from the largest heap to make it match the second largest heap\n        vals = sorted(state, reverse=True)\n        i_largest = state.index(vals[0])  # largest heap\n        state[i_largest] -= max(vals[0] - vals[1], 1)  # must take some, take 1 in case of tie\n\n    def losing(h):  # return True if h is a losing state\n        xor = 0\n        for i in h:\n            xor ^= i\n        return xor == 0\n\n    def optimal_move():\n        assert not losing(state)\n        for i in range(len(state)):\n            for n in range(1, state[i] + 1):\n                state[i] -= n\n                if losing(state):\n                    moves.append([i, n])\n                    return\n                state[i] += n\n        assert False, \"Shouldn't reach hear\"\n\n    while True:\n        optimal_move()\n        if max(state) == 0:\n            return moves\n        bot_move()"], "module": "games.py", "notes": "Compute optimal play for the classic two-player game [Nim](https://en.wikipedia.org/wiki/Nim)\n\nNim has an elegant theory for optimal play based on the xor of the bits in the heaps.\n\nInstead of writing a program that plays the game interactively (since interaction is not allowed), we require\nthem to determine winning states or beat a certain opponent.", "weight": 10.0}, {"name": "RockPaperScissors:0", "sat": "def sat(probs: List[float]):\n    assert len(probs) == 3 and abs(sum(probs) - 1) < 1e-6\n    return max(probs[(i + 2) % 3] - probs[(i + 1) % 3] for i in range(3)) < 1e-6", "ans_type": "List[float]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find optimal probabilities for playing Rock-Paper-Scissors zero-sum game, with best worst-case guarantee\"\"\"", "sol_bodies": ["    return [1 / 3] * 3"], "module": "games.py", "notes": "", "weight": 1.0}, {"name": "Nash:4", "sat": "def sat(strategies: List[List[float]], A=[[0.5753373910044396, 0.883286704506171, 0.14098419242590676, 0.0796482735170555, 0.28053511699815137, 0.4802587237433614, 0.7927565741942321, 0.10486790699611082], [0.674897469149739, 0.5526354958094333, 0.14126552040252316, 0.8176885681560745, 0.5950057513195114, 0.9394498004514682, 0.9974412293717752, 0.31785998202168364], [0.8551492483900579, 0.0873581901597057, 0.7058504781434135, 0.8614481823894408, 0.774002479389802, 0.5194163269795865, 0.8839947283493329, 0.4796849532033839], [0.24669121918914239, 0.9192009909426845, 0.22533689422848313, 0.42231986064003346, 0.8524917527913644, 0.3217815290765713, 0.13012568628724053, 0.08517580086974996], [0.6708003793106111, 0.9370021425919828, 0.956981559137809, 0.48294825852969425, 0.09451427192867867, 0.958711015678715, 0.13874285709747414, 0.17240487357189138], [0.6862479923713413, 0.40988185301904767, 0.7232258320050972, 0.12156129874113497, 0.4137204968814412, 0.43096712555208105, 0.9673727161037606, 0.9554536674896775], [0.2645245766573283, 0.16353379162998616, 0.8208329137057697, 0.24945486012929086, 0.19060921538692044, 0.6886849242360286, 0.6513544853108113, 0.13898253443118158], [0.8399423196728664, 0.5583901386668076, 0.05055384968867316, 0.272512815876485, 0.4706764309925491, 0.9920874820129374, 0.11006687231735834, 0.6003338823254668]], B=[[0.8661101149166154, 0.5041424261188884, 0.654530488206357, 0.842287965510257, 0.5418722524658692, 0.615317049155107, 0.2474305118268787, 0.802249852604974], [0.17399126319302805, 0.37286827574250436, 0.9025123265462714, 0.6302774019777034, 0.6096954531215514, 0.14282756248667317, 0.5039665393854678, 0.5053857713064859], [0.08645764165911696, 0.34639849481946294, 0.4003286765389642, 0.8522825407634552, 0.38924375107949505, 0.13708630962779877, 0.09413370097193263, 0.024977157717289145], [0.18665183173707744, 0.08210966062569414, 0.8906028770829486, 0.9292380534706237, 0.3432700204525524, 0.03791015448620483, 0.23701146631134296, 0.5236370615896554], [0.4158240648499627, 0.620309795706114, 0.6606023798050246, 0.7581954943445194, 0.9399309644265448, 0.6640739757418763, 0.5470483802958659, 0.3881528058493644], [0.8452380694038372, 0.7687623496765781, 0.22422282300746144, 0.03236167241305821, 0.1113965246318579, 0.4589759506900418, 0.8415359432321317, 0.27521377409486303], [0.6582156349227984, 0.9988816473957544, 0.4901663751981855, 0.3788210957458895, 0.455713995042737, 0.04960398762882756, 0.16850674065572013, 0.6202540021741917], [0.7515673992699056, 0.6867547828670959, 0.038529441293790434, 0.9995963277046196, 0.15577904716257307, 0.2596640500026437, 0.76139213514593, 0.5065163836406463]], eps=0.01):\n    m, n = len(A), len(A[0])\n    p, q = strategies\n    assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n    assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n    assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n    v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n    return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n            all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))", "ans_type": "List[List[float]]", "sol_header": "def sol(A=[[0.5753373910044396, 0.883286704506171, 0.14098419242590676, 0.0796482735170555, 0.28053511699815137, 0.4802587237433614, 0.7927565741942321, 0.10486790699611082], [0.674897469149739, 0.5526354958094333, 0.14126552040252316, 0.8176885681560745, 0.5950057513195114, 0.9394498004514682, 0.9974412293717752, 0.31785998202168364], [0.8551492483900579, 0.0873581901597057, 0.7058504781434135, 0.8614481823894408, 0.774002479389802, 0.5194163269795865, 0.8839947283493329, 0.4796849532033839], [0.24669121918914239, 0.9192009909426845, 0.22533689422848313, 0.42231986064003346, 0.8524917527913644, 0.3217815290765713, 0.13012568628724053, 0.08517580086974996], [0.6708003793106111, 0.9370021425919828, 0.956981559137809, 0.48294825852969425, 0.09451427192867867, 0.958711015678715, 0.13874285709747414, 0.17240487357189138], [0.6862479923713413, 0.40988185301904767, 0.7232258320050972, 0.12156129874113497, 0.4137204968814412, 0.43096712555208105, 0.9673727161037606, 0.9554536674896775], [0.2645245766573283, 0.16353379162998616, 0.8208329137057697, 0.24945486012929086, 0.19060921538692044, 0.6886849242360286, 0.6513544853108113, 0.13898253443118158], [0.8399423196728664, 0.5583901386668076, 0.05055384968867316, 0.272512815876485, 0.4706764309925491, 0.9920874820129374, 0.11006687231735834, 0.6003338823254668]], B=[[0.8661101149166154, 0.5041424261188884, 0.654530488206357, 0.842287965510257, 0.5418722524658692, 0.615317049155107, 0.2474305118268787, 0.802249852604974], [0.17399126319302805, 0.37286827574250436, 0.9025123265462714, 0.6302774019777034, 0.6096954531215514, 0.14282756248667317, 0.5039665393854678, 0.5053857713064859], [0.08645764165911696, 0.34639849481946294, 0.4003286765389642, 0.8522825407634552, 0.38924375107949505, 0.13708630962779877, 0.09413370097193263, 0.024977157717289145], [0.18665183173707744, 0.08210966062569414, 0.8906028770829486, 0.9292380534706237, 0.3432700204525524, 0.03791015448620483, 0.23701146631134296, 0.5236370615896554], [0.4158240648499627, 0.620309795706114, 0.6606023798050246, 0.7581954943445194, 0.9399309644265448, 0.6640739757418763, 0.5470483802958659, 0.3881528058493644], [0.8452380694038372, 0.7687623496765781, 0.22422282300746144, 0.03236167241305821, 0.1113965246318579, 0.4589759506900418, 0.8415359432321317, 0.27521377409486303], [0.6582156349227984, 0.9988816473957544, 0.4901663751981855, 0.3788210957458895, 0.455713995042737, 0.04960398762882756, 0.16850674065572013, 0.6202540021741917], [0.7515673992699056, 0.6867547828670959, 0.038529441293790434, 0.9995963277046196, 0.15577904716257307, 0.2596640500026437, 0.76139213514593, 0.5065163836406463]], eps=0.01):", "sol_docstring": "    \"\"\"\n    Find an eps-Nash-equilibrium for a given two-player game with payoffs described by matrices A, B.\n    For example, for the classic Prisoner dilemma:\n       A=[[-1., -3.], [0., -2.]], B=[[-1., 0.], [-3., -2.]], and strategies = [[0, 1], [0, 1]]\n\n    eps is the error tolerance\n    \"\"\"", "sol_bodies": ["    NUM_ATTEMPTS = 10 ** 5\n\n    def sat(strategies: List[List[float]], A, B, eps):\n        m, n = len(A), len(A[0])\n        p, q = strategies\n        assert len(B) == m and all(len(row) == n for row in A + B), \"inputs are a bimatrix game\"\n        assert len(p) == m and len(q) == n, \"solution is a pair of strategies\"\n        assert sum(p) == sum(q) == 1.0 and min(p + q) >= 0.0, \"strategies must be non-negative and sum to 1\"\n        v = sum(A[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        w = sum(B[i][j] * p[i] * q[j] for i in range(m) for j in range(n))\n        return (all(sum(A[i][j] * q[j] for j in range(n)) <= v + eps for i in range(m)) and\n                all(sum(B[i][j] * p[i] for i in range(m)) <= w + eps for j in range(n)))\n\n    import random\n    r = random.Random(0)\n    dims = len(A), len(A[0])\n    # possible speedup: remove dominated strategies\n    for _attempt in range(NUM_ATTEMPTS):\n        strategies = []\n        for d in dims:\n            s = [max(0.0, r.random() - 0.5) for _ in range(d)]\n            tot = sum(s) + 1e-6\n            for i in range(d):\n                s[i] = (1.0 - sum(s[:-1])) if i == d - 1 else (s[i] / tot)  # to ensure sum is exactly 1.0\n            strategies.append(s)\n        if sat(strategies, A, B, eps):\n            return strategies"], "module": "games.py", "notes": "Computing a [Nash equilibrium](https://en.wikipedia.org/wiki/Nash_equilibrium) for a given\n[bimatrix game](https://en.wikipedia.org/wiki/Bimatrix_game) is known to be\nPPAD-hard in general. However, the challenge is be much easier for an approximate\n[eps-equilibrium](https://en.wikipedia.org/wiki/Epsilon-equilibrium) and of course for small games.", "weight": 5.0}, {"name": "Conway99:0", "sat": "def sat(edges: List[List[int]]):\n    # first compute neighbors sets, N:\n    N = {i: {j for j in range(99) if j != i and ([i, j] in edges or [j, i] in edges)} for i in range(99)}\n    return all(len(N[i].intersection(N[j])) == (1 if j in N[i] else 2) for i in range(99) for j in range(i))", "ans_type": "List[List[int]]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Find an undirected graph with 99 vertices, in which each two adjacent vertices have exactly one common\n    neighbor, and in which each two non-adjacent vertices have exactly two common neighbors.\n    \"\"\"", "sol_bodies": [], "module": "graphs.py", "notes": "Conway's 99-graph problem (*unsolved*, open problem)\n\nConway's 99-graph problem is an unsolved problem in graph theory.\nIn Conway's terminology, from [Five $1,000 Problems (Update 2017)](https://oeis.org/A248380/a248380.pdf)\n\"Is there a graph with 99 vertices in which every edge (i.e. pair of joined vertices) belongs to a unique\ntriangle and every nonedge (pair of unjoined vertices) to a unique quadrilateral?\"\n\nSee also this [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Conway%27s_99-graph_problem).", "weight": 1.0}, {"name": "AnyTriangle:0", "sat": "def sat(tri: List[int], edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):\n    a, b, c = tri\n    return [a, b] in edges and [b, c] in edges and [c, a] in edges and a != b != c != a", "ans_type": "List[int]", "sol_header": "def sol(edges=[[0, 17], [0, 22], [17, 22], [17, 31], [22, 31], [31, 17]]):", "sol_docstring": "    \"\"\"Find any triangle in the given directed graph.\"\"\"", "sol_bodies": ["    from collections import defaultdict\n    outs = defaultdict(set)\n    ins = defaultdict(set)\n    for i, j in edges:\n        if j != i:\n            outs[i].add(j)\n            ins[j].add(i)\n    for i in outs:\n        for j in outs[i]:\n            try:\n                if j in outs:\n                    k = min(outs[j].intersection(ins[i]))\n                    return [i, j, k]\n            except ValueError:\n                pass"], "module": "graphs.py", "notes": "Easy [graph](https://en.wikipedia.org/w/index.php?title=Graph_(discrete_mathematics)) problem,\nsee [triangle](https://en.wikipedia.org/w/index.php?title=Triangle_graph)", "weight": 1.0}, {"name": "ShortestPath:4", "sat": "def sat(path: List[int], weights=[{1: 996, 2: 237, 4: 264}, {4: 329, 5: 12, 2: 542, 0: 419}, {2: 170, 6: 339, 5: 211}, {1: 714, 5: 885, 3: 640}, {5: 652, 4: 3, 3: 26, 6: 74}, {0: 647, 5: 346}, {2: 297, 6: 358, 3: 636, 0: 722, 4: 942}], bound=996):\n    return path[0] == 0 and path[-1] == 1 and sum(weights[a][b] for a, b in zip(path, path[1:])) <= bound", "ans_type": "List[int]", "sol_header": "def sol(weights=[{1: 996, 2: 237, 4: 264}, {4: 329, 5: 12, 2: 542, 0: 419}, {2: 170, 6: 339, 5: 211}, {1: 714, 5: 885, 3: 640}, {5: 652, 4: 3, 3: 26, 6: 74}, {0: 647, 5: 346}, {2: 297, 6: 358, 3: 636, 0: 722, 4: 942}], bound=996):", "sol_docstring": "    \"\"\"\n    Find a path from node 0 to node 1, of length at most bound, in the given digraph.\n    weights[a][b] is weight on edge [a,b] for (int) nodes a, b\n    \"\"\"", "sol_bodies": ["    # Dijkstra's algorithm (bound is ignored)\n    u, v = 0, 1  # go from 0 to 1\n    import heapq\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in weights[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + weights[i][j], j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"], "module": "graphs.py", "notes": "Shortest Path, see (Dijkstra's algorithm)[https://en.wikipedia.org/w/index.php?title=Dijkstra%27s_algorithm]", "weight": 1.0}, {"name": "UnweightedShortestPath:1", "sat": "def sat(path: List[int], edges=[[12, 4], [33, 15], [37, 12], [11, 1], [34, 19], [42, 36], [2, 38], [6, 25], [29, 25], [30, 6], [16, 31], [10, 41], [15, 2], [3, 19], [1, 26], [17, 17], [19, 4], [0, 6], [42, 5], [11, 13], [22, 15], [39, 11], [35, 34], [39, 20], [7, 31], [38, 27], [9, 30], [31, 25], [0, 9], [13, 34], [31, 34], [19, 42], [37, 32], [4, 13], [11, 43], [14, 0], [22, 41], [20, 17], [0, 15], [13, 4], [20, 6], [34, 42], [42, 10], [32, 19], [41, 8], [26, 42], [0, 13], [28, 42], [9, 0], [32, 26], [6, 4], [27, 19], [37, 9], [7, 6], [25, 14], [23, 14], [31, 39], [18, 27], [34, 36], [24, 16], [24, 31], [16, 17], [2, 4], [34, 40], [28, 6], [41, 9], [17, 18], [43, 11], [11, 39], [43, 29], [1, 19], [27, 27], [4, 42], [0, 16], [16, 14], [40, 22], [22, 22], [38, 16], [3, 34], [33, 23], [2, 18], [3, 11], [4, 5], [18, 3], [23, 11], [41, 22], [7, 26], [31, 42], [35, 33], [15, 28], [34, 10], [36, 3], [9, 38], [17, 5], [3, 9], [37, 21], [36, 1], [25, 6], [22, 12], [42, 3], [16, 32], [0, 11], [24, 33], [15, 31], [18, 34], [11, 8], [30, 41], [19, 19], [4, 11], [22, 16], [1, 13], [6, 22], [12, 30], [19, 15], [3, 21], [38, 29], [32, 39], [1, 17], [16, 20], [10, 39], [32, 27], [37, 6], [18, 18], [22, 32], [31, 32], [24, 32], [22, 25], [38, 18], [38, 21], [39, 12], [9, 17], [10, 42], [29, 36], [34, 23], [27, 29], [17, 24], [24, 28], [31, 23], [28, 7], [5, 2], [24, 26], [27, 13], [43, 19], [37, 36], [2, 13], [10, 11], [30, 11], [29, 32], [4, 24], [17, 27], [21, 2], [24, 43], [26, 37], [16, 6], [43, 35], [42, 27], [26, 12], [39, 3], [38, 25], [20, 5], [36, 8], [25, 42], [27, 40], [39, 23], [6, 12], [27, 32], [12, 34], [2, 5], [40, 35], [15, 12], [22, 29], [21, 11], [0, 22], [13, 23], [27, 4], [35, 24], [32, 29], [4, 14], [9, 7], [32, 11], [11, 26], [26, 41], [2, 16], [38, 23], [30, 29], [6, 31], [1, 34], [4, 39], [24, 3], [25, 22], [9, 14], [33, 26], [34, 38], [35, 29], [32, 38], [5, 42], [42, 24], [15, 38], [41, 14], [39, 9], [4, 36], [21, 24], [36, 9]], u=14, v=1, bound=4):\n    assert path[0] == u and path[-1] == v and all([i, j] in edges for i, j in zip(path, path[1:]))\n    return len(path) <= bound", "ans_type": "List[int]", "sol_header": "def sol(u=14, v=1, edges=[[12, 4], [33, 15], [37, 12], [11, 1], [34, 19], [42, 36], [2, 38], [6, 25], [29, 25], [30, 6], [16, 31], [10, 41], [15, 2], [3, 19], [1, 26], [17, 17], [19, 4], [0, 6], [42, 5], [11, 13], [22, 15], [39, 11], [35, 34], [39, 20], [7, 31], [38, 27], [9, 30], [31, 25], [0, 9], [13, 34], [31, 34], [19, 42], [37, 32], [4, 13], [11, 43], [14, 0], [22, 41], [20, 17], [0, 15], [13, 4], [20, 6], [34, 42], [42, 10], [32, 19], [41, 8], [26, 42], [0, 13], [28, 42], [9, 0], [32, 26], [6, 4], [27, 19], [37, 9], [7, 6], [25, 14], [23, 14], [31, 39], [18, 27], [34, 36], [24, 16], [24, 31], [16, 17], [2, 4], [34, 40], [28, 6], [41, 9], [17, 18], [43, 11], [11, 39], [43, 29], [1, 19], [27, 27], [4, 42], [0, 16], [16, 14], [40, 22], [22, 22], [38, 16], [3, 34], [33, 23], [2, 18], [3, 11], [4, 5], [18, 3], [23, 11], [41, 22], [7, 26], [31, 42], [35, 33], [15, 28], [34, 10], [36, 3], [9, 38], [17, 5], [3, 9], [37, 21], [36, 1], [25, 6], [22, 12], [42, 3], [16, 32], [0, 11], [24, 33], [15, 31], [18, 34], [11, 8], [30, 41], [19, 19], [4, 11], [22, 16], [1, 13], [6, 22], [12, 30], [19, 15], [3, 21], [38, 29], [32, 39], [1, 17], [16, 20], [10, 39], [32, 27], [37, 6], [18, 18], [22, 32], [31, 32], [24, 32], [22, 25], [38, 18], [38, 21], [39, 12], [9, 17], [10, 42], [29, 36], [34, 23], [27, 29], [17, 24], [24, 28], [31, 23], [28, 7], [5, 2], [24, 26], [27, 13], [43, 19], [37, 36], [2, 13], [10, 11], [30, 11], [29, 32], [4, 24], [17, 27], [21, 2], [24, 43], [26, 37], [16, 6], [43, 35], [42, 27], [26, 12], [39, 3], [38, 25], [20, 5], [36, 8], [25, 42], [27, 40], [39, 23], [6, 12], [27, 32], [12, 34], [2, 5], [40, 35], [15, 12], [22, 29], [21, 11], [0, 22], [13, 23], [27, 4], [35, 24], [32, 29], [4, 14], [9, 7], [32, 11], [11, 26], [26, 41], [2, 16], [38, 23], [30, 29], [6, 31], [1, 34], [4, 39], [24, 3], [25, 22], [9, 14], [33, 26], [34, 38], [35, 29], [32, 38], [5, 42], [42, 24], [15, 38], [41, 14], [39, 9], [4, 36], [21, 24], [36, 9]], bound=4):", "sol_docstring": "    \"\"\"Find a path from node u to node v, of a bounded length, in the given digraph on vertices 0, 1,..., n.\"\"\"", "sol_bodies": ["    # Dijkstra's algorithm\n    import heapq\n    from collections import defaultdict\n    queue = [(0, u, u)]  # distance, node, trail\n\n    trails = {}\n    neighbors = defaultdict(set)\n    for (i, j) in edges:\n        neighbors[i].add(j)\n\n    while queue:\n        dist, i, j = heapq.heappop(queue)\n        if i in trails:\n            continue\n        trails[i] = j\n        if i == v:\n            break\n        for j in neighbors[i]:\n            if j not in trails:\n                heapq.heappush(queue, (dist + 1, j, i))\n    if v in trails:\n        rev_path = [v]\n        while rev_path[-1] != u:\n            rev_path.append(trails[rev_path[-1]])\n        return rev_path[::-1]"], "module": "graphs.py", "notes": "Unweighted Shortest Path\n\nSee (Dijkstra's algorithm)[https://en.wikipedia.org/w/index.php?title=Dijkstra%27s_algorithm]", "weight": 1.0}, {"name": "AnyPath:2", "sat": "def sat(path: List[int], edges=[[0, 0]]):\n    for i in range(len(path) - 1):\n        assert [path[i], path[i + 1]] in edges\n    assert path[0] == 0\n    assert path[-1] == max(max(edge) for edge in edges)\n    return True", "ans_type": "List[int]", "sol_header": "def sol(edges=[[0, 0]]):", "sol_docstring": "    \"\"\" Find any path from node 0 to node n in a given digraph on vertices 0, 1,..., n.\"\"\"", "sol_bodies": ["    n = max(max(edge) for edge in edges)\n    paths = {0: [0]}\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in paths and j not in paths:\n                paths[j] = paths[i] + [j]\n    return paths.get(n)"], "module": "graphs.py", "notes": "Any Path", "weight": 1.0}, {"name": "EvenPath:0", "sat": "def sat(path: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):\n    assert path[0] == 0 and path[-1] == max(max(e) for e in edges)\n    assert all([[a, b] in edges for a, b in zip(path, path[1:])])\n    return len(path) % 2 == 0", "ans_type": "List[int]", "sol_header": "def sol(edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [1, 2]]):", "sol_docstring": "    \"\"\"Find a path with an even number of nodes from nodes 0 to n in the given digraph on vertices 0, 1,..., n.\"\"\"", "sol_bodies": ["    even_paths = {}\n    odd_paths = {0: [0]}\n    n = max(max(e) for e in edges)\n    for _ in range(n + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return even_paths.get(n)"], "module": "graphs.py", "notes": "", "weight": 1.0}, {"name": "OddPath:0", "sat": "def sat(p: List[int], edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):\n    return p[0] == 0 and p[-1] == 1 == len(p) % 2 and all([[a, b] in edges for a, b in zip(p, p[1:])])", "ans_type": "List[int]", "sol_header": "def sol(edges=[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [3, 4], [5, 6], [6, 7], [6, 1]]):", "sol_docstring": "    \"\"\"Find a path with an even number of nodes from nodes 0 to 1 in the given digraph on vertices 0, 1,..., n.\"\"\"", "sol_bodies": ["    even_paths = {}\n    odd_paths = {0: [0]}\n    n = 1\n    for _ in range(max(max(e) for e in edges) + 1):\n        for i, j in edges:\n            if i in even_paths and j not in odd_paths:\n                odd_paths[j] = even_paths[i] + [j]\n            if i in odd_paths and j not in even_paths:\n                even_paths[j] = odd_paths[i] + [j]\n    return odd_paths.get(n)"], "module": "graphs.py", "notes": "To make it even more different than EvenPath, we changed to go from node 0 to node *1*.", "weight": 1.0}, {"name": "GraphIsomorphism:2", "sat": "def sat(bi: List[int], g1=[[0, 1], [0, 7], [1, 1], [2, 0], [2, 3], [2, 5], [2, 6], [3, 0], [3, 1], [3, 2], [3, 5], [3, 6], [3, 7], [4, 3], [4, 5], [4, 6], [5, 0], [5, 2], [5, 3], [6, 0], [6, 5], [6, 7], [7, 0], [7, 4], [7, 6]], g2=[[0, 7], [7, 1], [0, 2], [3, 1], [2, 0], [7, 0], [0, 6], [4, 7], [2, 7], [7, 6], [1, 6], [3, 6], [6, 5], [1, 3], [7, 3], [4, 0], [1, 0], [3, 4], [2, 1], [2, 6], [7, 2], [6, 3], [7, 5], [4, 1], [5, 5]]):\n    return len(bi) == len(set(bi)) and {(i, j) for i, j in g1} == {(bi[i], bi[j]) for i, j in g2}", "ans_type": "List[int]", "sol_header": "def sol(g1=[[0, 1], [0, 7], [1, 1], [2, 0], [2, 3], [2, 5], [2, 6], [3, 0], [3, 1], [3, 2], [3, 5], [3, 6], [3, 7], [4, 3], [4, 5], [4, 6], [5, 0], [5, 2], [5, 3], [6, 0], [6, 5], [6, 7], [7, 0], [7, 4], [7, 6]], g2=[[0, 7], [7, 1], [0, 2], [3, 1], [2, 0], [7, 0], [0, 6], [4, 7], [2, 7], [7, 6], [1, 6], [3, 6], [6, 5], [1, 3], [7, 3], [4, 0], [1, 0], [3, 4], [2, 1], [2, 6], [7, 2], [6, 3], [7, 5], [4, 1], [5, 5]]):", "sol_docstring": "    \"\"\"\n    You are given two graphs which are permutations of one another and the goal is to find the permutation.\n    Each graph is specified by a list of edges where each edge is a pair of integer vertex numbers.\n    \"\"\"", "sol_bodies": ["    # exponentially slow\n    from itertools import permutations\n    n = max(i for g in [g1, g2] for e in g for i in e) + 1\n    g1_set = {(i, j) for i, j in g1}\n    for pi in permutations(range(n)):\n        if all((pi[i], pi[j]) in g1_set for i, j in g2):\n            return list(pi)\n    assert False, f\"Graphs are not isomorphic {g1}, {g2}\""], "module": "graphs.py", "notes": "The classic [Graph Isomorphism](https://en.wikipedia.org/wiki/Graph_isomorphism) problem.\nIt is unknown whether or not there exists a polynomial-time algorithm\nfor this problem, though an unpublished quasi-polynomial-time algorithm has been announced by Babai.\n\nThe classic version is a decision problem: given two graphs, determine whether or not they are isomorphic.\nHowever, it is polynomial-time equivalent to the one below through a standard reduction. In particular, if you\ncould solve the search problem below (finding the actual bijection), then you can decide isomorphism because the\nsearch solver would simply fail on non-isomorphic graphs. Conversely, if you could solve the decision problem,\nthen you can find a bijection as follows: if the decider determines that the graphs are isomorphic, for each node\nin the first graph, find a corresponding node in the second graph as follows. Add N self-edges from the node to\nitself where N is the maximum degree in the graph + 1, and do that for each candidate node in the second graph.\nFor each of these additions, test isomorphism. If the graphs are isomorphic then there must be a bijection that maps\nthe first node to the second. Repeat this for each node until you have found a bijection. (If self-loops are not\nallowed, one can do this by adding N additional nodes for each test.", "weight": 1.0}, {"name": "CheckersPosition:3", "sat": "def sat(position: List[List[int]], transcript=[[[3, 1], [1, 3]]]):\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True", "ans_type": "List[List[int]]", "sol_header": "def sol(transcript=[[[3, 1], [1, 3]]]):", "sol_docstring": "    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"", "sol_bodies": ["    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"], "module": "ICPC.py", "notes": "Inspired by\n[ICPC 2019 Problem C: Checks Post Facto](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\n\nNobody solved this problem during the competition -- it is pretty difficult!", "weight": 1.0}, {"name": "MatchingMarkers:4", "sat": "def sat(cut_position: int, ring=\"ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf\", lower=1):\n    line = ring[cut_position:] + ring[:cut_position]\n    matches = {c: 0 for c in line.lower()}\n    for c in line:\n        if c.islower():\n            matches[c] -= (1 if matches[c] > 0 else len(line))\n        else:\n            matches[c.lower()] += 1\n    return sum(i == 0 for i in matches.values()) >= lower", "ans_type": "int", "sol_header": "def sol(ring=\"ClaKdLCuSddLdafuRKuqUqSLqquLCSlrCfFdcRAlfkLlqqqccQSacsDCUqDaLurDlqqfcAaKasCf\", lower=1):", "sol_docstring": "    \"\"\"\n    The input is a string of start and end markers \"aaBAcGeg\" where upper-case characters indicate start markers\n    and lower-case characters indicate ending markers. The string indicates a ring (joined at the ends) and the goal is\n    to find a location to split the ring so that there are a maximal number of matched start/end chars where a character\n    (like \"a\"/\"A\") is matched if starting at the split and going around the ring, the start-end pairs form a valid\n    nesting like nested parentheses. Can you solve it in linear time?\n    \"\"\"", "sol_bodies": ["    cumulatives = {c: [(0, 0)] for c in ring.lower()}\n    n = len(ring)\n    for i, c in enumerate(ring):\n        v = cumulatives[c.lower()]\n        v.append((i, v[-1][1] + (-1 if c.islower() else 1)))\n\n    scores = [0]*n\n    cumulatives = {c: v for c, v in cumulatives.items() if v[-1][1]==0}\n    for c, v in cumulatives.items():\n        if v[-1][1] != 0: # ignore things with unequal numbers of opens and closes\n            continue\n        m = min(t for i, t in v)\n        for (i, t), (i2, t2) in zip(v, v[1:] + [(n, 0)]):\n            if t == m:\n                for j in range(i+1, i2+1):\n                    scores[j % n] += 1\n    b = max(scores)\n    for i in range(n):\n        if scores[i] == b:\n            return i"], "module": "ICPC.py", "notes": "Inspired by\n[ICPC 2019 Problem D: Circular DNA](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\n\nThis is trivial in quadratic time, but the challenge is to solve it quickly (i.e., linear time).", "weight": 1.0}, {"name": "NoRelativePrimes:1", "sat": "def sat(nums: List[int], b=7, m=26):\n    assert len(nums) == len(set(nums)) == m and min(nums) >= 0\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    for a in nums:\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        assert all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums)\n\n    return True", "ans_type": "List[int]", "sol_header": "def sol(b=7, m=26):", "sol_docstring": "    \"\"\"\n    Let P(n) = n^2 + n + 1.\n\n    Given b>=6 and m>=1, find m non-negative integers for which the set {P(a+1), P(a+2), ..., P(a+b)} has\n    the property that there is no element that is relatively prime to every other element.\n\n    Sample input:\n    b = 6\n    m = 2\n\n    Sample output:\n    [195, 196]\n    \"\"\"", "sol_bodies": ["    ans = []\n\n    seen = set()\n    deltas = set()\n\n    def go(a):\n        if a < 0 or a in seen or len(ans) == m:\n            return\n        seen.add(a)\n        nums = [(a + i + 1) ** 2 + (a + i + 1) + 1 for i in range(b)]\n        if all(any(i != j and gcd(i, j) > 1 for j in nums) for i in nums):\n            new_deltas = [abs(a - a2) for a2 in ans if a != a2 and abs(a - a2) not in deltas]\n            ans.append(a)\n            for delta in new_deltas:\n                for a2 in ans:\n                    go(a2 + delta)\n                    go(a2 - delta)\n            deltas.update(new_deltas)\n            for delta in sorted(deltas):\n                go(a + delta)\n\n    def gcd(i, j):\n        r, s = max(i, j), min(i, j)\n        while s >= 1:\n            r, s = s, (r % s)\n        return r\n\n    a = 0\n\n    while len(ans) < m:\n        go(a)\n        a += 1\n\n    return ans"], "module": "IMO.py", "notes": "Inspired by [IMO 2016 Problem 4](https://www.imo-official.org/problems.aspx)\n\nQuestion: Is there a more efficient solution than the brute-force one we give, perhaps using the Chinese remainder\ntheorem?", "weight": 1.0}, {"name": "FindRepeats:2", "sat": "def sat(indices: List[int], a0=2362263):\n    assert a0 >= 0 and a0 % 3 == 0, \"Hint: a_0 is a multiple of 3.\"\n    s = [a0]\n    for i in range(max(indices)):\n        s.append(int(s[-1] ** 0.5) if int(s[-1] ** 0.5) ** 2 == s[-1] else s[-1] + 3)\n    return len(indices) == len(set(indices)) == 1000 and min(indices) >= 0 and len({s[i] for i in indices}) == 1", "ans_type": "List[int]", "sol_header": "def sol(a0=2362263):", "sol_docstring": "    \"\"\"\n    Find a repeating integer in an infinite sequence of integers, specifically the indices for which the same value\n    occurs 1000 times. The sequence is defined by a starting value a_0 and each subsequent term is:\n    a_{n+1} = the square root of a_n if the a_n is a perfect square, and a_n + 3 otherwise.\n\n    For a given a_0 (that is a multiple of 3), the goal is to find 1000 indices where the a_i's are all equal.\n\n    Sample input:\n    9\n\n    Sample output:\n    [0, 3, 6, ..., 2997]\n\n    The sequence starting with a0=9 is [9, 3, 6, 9, 3, 6, 9, ...] thus a_n at where n is a multiple of 3 are\n    all equal in this case.\n    \"\"\"", "sol_bodies": ["    n = a0\n    ans = []\n    i = 0\n    while len(ans) < 1000:\n        if n == 3:  # use the fact that 3 will repeat infinitely often\n            ans.append(i)\n        n = int(n ** 0.5) if int(n ** 0.5) ** 2 == n else n + 3\n        i += 1\n    return ans"], "module": "IMO.py", "notes": "Note: This problem is much easier than the IMO problem which also required a proof that it is impossible\nfor a_0 not divisible by 3.\n\nInspired by [IMO 2017 Problem 1](https://www.imo-official.org/problems.aspx)", "weight": 1.0}, {"name": "FindProductiveList:3", "sat": "def sat(li: List[int], n=9):\n    assert n % 3 == 0, \"Hint: n is a multiple of 3\"\n    return len(li) == n and all(li[(i + 2) % n] == 1 + li[(i + 1) % n] * li[i] for i in range(n))", "ans_type": "List[int]", "sol_header": "def sol(n=9):", "sol_docstring": "    \"\"\"\n    Given n, find n integers such that li[i] * li[i+1] + 1 == li[i+2], for i = 0, 1, ..., n-1\n    where indices >= n \"wrap around\". Note: only n multiples of 3 are given since this is only possible for n\n    that are multiples of 3 (as proven in the IMO problem).\n\n    Sample input:\n    6\n\n    Sample output:\n    [_, _, _, _, _, _]\n\n    (Sample output hidden because showing sample output would give away too much information.)\n    \"\"\"", "sol_bodies": ["    return [-1, -1, 2] * (n // 3)"], "module": "IMO.py", "notes": "Note: This problem is easier than the IMO problem because the hard part is proving that sequences do not\nexists for non-multiples of 3.\n\nInspired by [IMO 2010 Problem 5](https://www.imo-official.org/problems.aspx)", "weight": 1.0}, {"name": "LearnParity:2", "sat": "def sat(inds: List[int], vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):\n    return all(sum((v >> i) & 1 for i in inds) % 2 == 1 for v in vecs)", "ans_type": "List[int]", "sol_header": "def sol(vecs=[22, 30, 1, 28, 28, 12, 20, 28, 6, 14, 14, 6, 1, 12]):", "sol_docstring": "    \"\"\"\n    Parity learning: Given binary vectors in a subspace, find the secret set S of indices such that:\n    $\\\\sum_{i \\in S} x_i = 1 (mod 2)$\n    \"\"\"", "sol_bodies": ["    # Gaussian elimination\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n    ans = []\n    pool = [[0] * (d + 1) for _ in range(d)] + [v + [1] for v in vecs]\n    for i in range(d):\n        pool[i][i] = 1\n\n    for i in range(d):  # zero out bit i\n        for v in pool[d:]:\n            if v[i] == 1:\n                break\n        if v[i] == 0:\n            v = pool[i]\n        assert v[i] == 1  # found a vector with v[i] = 1, subtract it off from those with a 1 in the ith coordinate\n        w = v[:]\n        for v in pool:\n            if v[i] == 1:\n                for j in range(d + 1):\n                    v[j] ^= w[j]\n\n    return [i for i in range(d) if pool[i][-1]]"], "module": "lattices.py", "notes": "Parity learning (Gaussian elimination)\n\nThe canonical solution to this \n[Parity learning problem](https://en.wikipedia.org/w/index.php?title=Parity_learning)\nis to use \n[Gaussian Elimination](https://en.wikipedia.org/w/index.php?title=Gaussian_elimination).\n\nThe vectors are encoded as binary integers for succinctness.", "weight": 1.0}, {"name": "LearnParityWithNoise:2", "sat": "def sat(inds: List[int], vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):\n    return sum(sum((v >> i) & 1 for i in inds) % 2 for v in vecs) >= len(vecs) * 3 / 4", "ans_type": "List[int]", "sol_header": "def sol(vecs=[576, 823, 480, 899, 652, 1017, 830, 125, 627, 889, 312, 663, 232, 856, 664, 594, 423, 810, 740, 828, 605, 580, 450, 905, 348]):", "sol_docstring": "    \"\"\"\n    Learning parity with noise: Given binary vectors, find the secret set $S$ of indices such that, for at least\n    3/4 of the vectors, $$sum_{i \\in S} x_i = 1 (mod 2)$$\n    \"\"\"", "sol_bodies": ["    # brute force\n    d = 0  # decode vectors into arrays\n    m = max(vecs)\n    while m:\n        m >>= 1\n        d += 1\n    vecs = [[(n >> i) & 1 for i in range(d)] for n in vecs]\n\n    import random\n    rand = random.Random(0)\n    target = (len(vecs) * 3) // 4\n    max_attempts = 10 ** 5\n    for _ in range(max_attempts):\n        ans = [i for i in range(d) if rand.randrange(2)]\n        if sum(sum(v[i] for i in ans) % 2 for v in vecs) >= len(vecs) * 3 / 4:\n            return ans"], "module": "lattices.py", "notes": "Learn parity with noise (*unsolved*)\n\nThe fastest known algorithm to this\n[Parity learning problem](https://en.wikipedia.org/w/index.php?title=Parity_learning)\nruns in time $2^(d/(log d))$\n\nThe example puzzle has small dimension so is easily solvable, but other instances are much harder.", "weight": 1.0}, {"name": "FermatsLastTheorem:0", "sat": "def sat(nums: List[int]):\n    a, b, c, n = nums\n    return (a ** n + b ** n == c ** n) and min(a, b, c) > 0 and n > 2", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find integers a,b,c > 0, n > 2, such such that a^n + b^n == c^n\"\"\"", "sol_bodies": [], "module": "number_theory.py", "notes": "[Fermat's last theorem](https://en.wikipedia.org/w/index.php?title=Fermat%27s_Last_Theorem)\n\nSupposedly unsolvable, but how confident are really in the super-complicated proof?\n\nSee [Wiles, Andrew. \"Modular elliptic curves and Fermat's last theorem.\" Annals of mathematics 141.3 (1995): 443-551.](https://www.jstor.org/stable/2118559)", "weight": 1.0}, {"name": "GCD:3", "sat": "def sat(n: int, a=247586288427023352, b=372021520735824432, lower_bound=1709054537):\n    return a % n == 0 and b % n == 0 and n >= lower_bound", "ans_type": "int", "sol_header": "def sol(a=247586288427023352, b=372021520735824432, lower_bound=1709054537):", "sol_docstring": "    \"\"\"Find a large common divisor of two integers.\"\"\"", "sol_bodies": ["    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n", "    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"], "module": "number_theory.py", "notes": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)", "weight": 1.0}, {"name": "GCD_multi:0", "sat": "def sat(n: int, nums=[77410, 23223, 54187], lower_bound=2):\n    return all(i % n == 0 for i in nums) and n >= lower_bound", "ans_type": "int", "sol_header": "def sol(nums=[77410, 23223, 54187], lower_bound=2):", "sol_docstring": "    \"\"\"Find a large common divisor of the list of integers.\"\"\"", "sol_bodies": ["    n = 0\n    for i in nums:\n        m, n = min(i, n), max(i, n)\n        while m > 0:\n            m, n = n % m, m\n    return n"], "module": "number_theory.py", "notes": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)", "weight": 1.0}, {"name": "LCM:4", "sat": "def sat(n: int, a=79680, b=661339968, upper_bound=410128528659):\n    return n % a == 0 and n % b == 0 and 0 < n <= upper_bound", "ans_type": "int", "sol_header": "def sol(a=79680, b=661339968, upper_bound=410128528659):", "sol_docstring": "    \"\"\"Find a small common multiple of two integers.\"\"\"", "sol_bodies": ["    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return a * (b // n)"], "module": "number_theory.py", "notes": "[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)\n(LCM)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)", "weight": 1.0}, {"name": "LCM_multi:1", "sat": "def sat(n: int, nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888):\n    return all(n % i == 0 for i in nums) and 0 < n <= upper_bound", "ans_type": "int", "sol_header": "def sol(nums=[46477686772963437, 15649966299, 37939312240, 14036122804591, 39209330717234], upper_bound=82396663973139497934429093888):", "sol_docstring": "    \"\"\"Find a small common multiple of a list of integers.\"\"\"", "sol_bodies": ["    ans = 1\n    for i in nums:\n        m, n = min(i, ans), max(i, ans)\n        while m > 0:\n            m, n = n % m, m\n        ans *= (i // n)\n    return ans"], "module": "number_theory.py", "notes": "[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)\n(LCM)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)", "weight": 1.0}, {"name": "FourSquares:0", "sat": "def sat(nums: List[int], n=12345):\n    return len(nums) <= 4 and sum(i ** 2 for i in nums) == n", "ans_type": "List[int]", "sol_header": "def sol(n=12345):", "sol_docstring": "    \"\"\"Find four integers whose squares sum to n\"\"\"", "sol_bodies": ["    m = n\n    squares = {i ** 2: i for i in range(int(m ** 0.5) + 2) if i ** 2 <= m}\n    sums_of_squares = {i + j: [a, b] for i, a in squares.items() for j, b in squares.items()}\n    for s in sums_of_squares:\n        if m - s in sums_of_squares:\n            return sums_of_squares[m - s] + sums_of_squares[s]\n    assert False, \"Should never reach here\""], "module": "number_theory.py", "notes": "Sum of four squares\n\n[Lagrange's Four Square Theorem](https://en.wikipedia.org/w/index.php?title=Lagrange%27s_four-square_theorem)\n\nGiven a non-negative integer `n`, a classic theorem of Lagrange says that `n` can be written as the sum of four\nintegers. The problem here is to find them. This is a nice problem and we give an elementary solution\nthat runs in time \tilde{O}(n),\nwhich is not \"polynomial time\" because it is not polynomial in log(n), the length of n. A poly-log(n)\nalgorithm using quaternions is described in the book:\n[\"Randomized algorithms in number theory\" by Michael O. Rabin and Jeffery O. Shallit (1986)](https://doi.org/10.1002/cpa.3160390713)\n\nThe first half of the problems involve small numbers and the second half involve some numbers up to 50 digits.", "weight": 1.0}, {"name": "Znam:1", "sat": "def sat(li: List[int], k=6):\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))", "ans_type": "List[int]", "sol_header": "def sol(k=6):", "sol_docstring": "    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"", "sol_bodies": ["    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"], "module": "number_theory.py", "notes": "[Znam's Problem](https://en.wikipedia.org/wiki/Zn%C3%A1m%27s_problem)\n\nFor example [2, 3, 7, 47, 395] is a solution for k=5", "weight": 1.0}, {"name": "CollatzCycleUnsolved:0", "sat": "def sat(n: int):\n    m = n\n    while n > 4:\n        n = 3 * n + 1 if n % 2 else n // 2\n        if n == m:\n            return True", "ans_type": "int", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find n > 4 which is part of a cycle of this process\n    \"\"\"", "sol_bodies": [], "module": "number_theory.py", "notes": "Collatz Conjecture\n\nA solution to this problem would disprove the *Collatz Conjecture*, also called the *3n + 1 problem*,\nas well as the *Generalized Collatz Conjecture* (see the next problem).\nAccording to the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture):\n> Paul Erdos said about the Collatz conjecture: \"Mathematics may not be ready for such problems.\"\n> He also offered US$500 for its solution. Jeffrey Lagarias stated in 2010 that the Collatz conjecture\n> \"is an extraordinarily difficult problem, completely out of reach of present day mathematics.\"\n\nConsider the following process. Start with an integer `n` and repeatedly applying the operation:\n* if n is even, divide n by 2,\n* if n is odd, multiply n by 3 and add 1\n\nThe conjecture is to that all `n > 0` eventually reach `n=1`. If this conjecture is false, then\nthere is either a cycle or a sequence that increases without bound. This problem seeks a cycle.", "weight": 1.0}, {"name": "CollatzGeneralizedUnsolved:0", "sat": "def sat(start: int):\n    n = start  # could be positive or negative ...\n    while abs(n) > 1000:\n        n = 3 * n + 1 if n % 2 else n // 2\n        if n == start:\n            return True", "ans_type": "int", "sol_header": "def sol():", "sol_docstring": "    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find n which is part of a cycle of this process that has |n| > 1000\n    \"\"\"", "sol_bodies": [], "module": "number_theory.py", "notes": "Generalized Collatz Conjecture\n\nThis version, permits negative n and seek a cycle with a number of magnitude greater than 1000,\nwhich would disprove the Generalized conjecture that states that the only cycles are the known 5 cycles\n(which don't have positive integers).\n\nSee the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture)", "weight": 1.0}, {"name": "CollatzDelay:2", "sat": "def sat(n: int, t=2000, upper=206):\n    m = n\n    for i in range(t):\n        if n <= 1:\n            return False\n        n = 3 * n + 1 if n % 2 else n // 2\n    return n == 1 and m <= 2 ** upper", "ans_type": "int", "sol_header": "def sol(t=2000, upper=206):", "sol_docstring": "    \"\"\"\n    Consider the following process. Start with an integer `n` and repeatedly applying the operation:\n    * if n is even, divide n by 2,\n    * if n is odd, multiply n by 3 and add 1\n    Find `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n    \"\"\"", "sol_bodies": [], "module": "number_theory.py", "notes": "Collatz Delay\n\nConsider the following process. Start with an integer `n` and repeatedly applying the operation:\n* if n is even, divide n by 2,\n* if n is odd, multiply n by 3 and add 1\nFind `0 < n < upper` so that it takes exactly `t` steps to reach 1.\n\n\nFor instance,\nthe number `n=9780657630` takes 1,132 steps and the number `n=93,571,393,692,802,302` takes\n2,091 steps, according to the [Wikipedia article](https://en.wikipedia.org/wiki/Collatz_conjecture)\n\nNow, this problem can be solved trivially by taking exponentially large `n = 2 ** t` so we also bound the\nnumber of bits of the solution to be upper.\n\nSee [this webpage](http://www.ericr.nl/wondrous/delrecs.html) for up-to-date records.", "weight": 1.0}, {"name": "Lehmer:0", "sat": "def sat(n: int):\n    return pow(2, n, n) == 3", "ans_type": "int", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find n  such that 2^n mod n = 3\"\"\"", "sol_bodies": ["    return 4700063497"], "module": "number_theory.py", "notes": "Lehmer puzzle\n\nAccording to [The Strong Law of Large Numbers](https://doi.org/10.2307/2322249) Richard K. Guy states that\n    D. H. & Emma Lehmer discovered that 2^n = 3 (mod n) for n = 4700063497,\n    but for no smaller n > 1", "weight": 1.0}, {"name": "BirthdayParadoxMonteCarlo:2", "sat": "def sat(n: int, year_len=2):\n    import random\n    random.seed(0)\n    K = 1000  # number of samples\n    prob = sum(len({random.randrange(year_len) for i in range(n)}) < n for j in range(K)) / K\n    return (prob - 0.5) ** 2 <= year_len", "ans_type": "int", "sol_header": "def sol(year_len=2):", "sol_docstring": "    \"\"\"Find n such that the probability of two people having the same birthday in a group of n is near 1/2.\"\"\"", "sol_bodies": ["    n = 1\n    distinct_prob = 1.0\n    best = (0.5, 1)  # (difference between probability and 1/2, n)\n    while distinct_prob > 0.5:\n        distinct_prob *= (year_len - n) / year_len\n        n += 1\n        best = min(best, (abs(0.5 - distinct_prob), n))\n\n    return best[1]"], "module": "probability.py", "notes": "A slower, Monte Carlo version of the above Birthday Paradox problem.", "weight": 1.0}, {"name": "BallotProblem:4", "sat": "def sat(counts: List[int], target_prob=0.7142857142857143):\n    m, n = counts  # m = num 1's, n = num -1's\n    probs = [1.0] + [0.0] * n  # probs[n] is probability for current m, starting with m = 1\n    for i in range(2, m + 1):  # compute probs using dynamic programming for m = i\n        old_probs = probs\n        probs = [1.0] + [0.0] * n\n        for j in range(1, min(n + 1, i)):\n            probs[j] = (\n                    j / (i + j) * probs[j - 1]  # last element is a -1 so use probs\n                    +\n                    i / (i + j) * old_probs[j]  # last element is a 1 so use old_probs, m = i - 1\n            )\n    return abs(probs[n] - target_prob) < 1e-6", "ans_type": "List[int]", "sol_header": "def sol(target_prob=0.7142857142857143):", "sol_docstring": "    \"\"\"\n    Suppose a list of m 1's and n -1's are permuted at random.\n    What is the probability that all of the cumulative sums are positive?\n    The goal is to find counts = [m, n] that make the probability of the ballot problem close to target_prob.\n    \"\"\"", "sol_bodies": ["    for m in range(1, 10000):\n        n = round(m * (1 - target_prob) / (1 + target_prob))\n        if abs(target_prob - (m - n) / (m + n)) < 1e-6:\n            return [m, n]"], "module": "probability.py", "notes": "See the [Wikipedia article](https://en.wikipedia.org/wiki/Bertrand%27s_ballot_theorem) or\nor  [Addario-Berry L., Reed B.A. (2008) Ballot Theorems, Old and New. In: Gyori E., Katona G.O.H., Lov\u00e1sz L.,\nS\u00e1gi G. (eds) Horizons of Combinatorics. Bolyai Society Mathematical Studies, vol 17.\nSpringer, Berlin, Heidelberg.](https://doi.org/10.1007/978-3-540-77200-2_1)", "weight": 1.0}, {"name": "HelloWorld:0", "sat": "def sat(s: str):\n    return s + 'world' == 'Hello world'", "ans_type": "str", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a string that when concatenated onto 'world' gives 'Hello world'.\"\"\"", "sol_bodies": [], "module": "trivial_inverse.py", "notes": "Trivial example, no solutions provided", "weight": 0.2}, {"name": "StrAdd:1", "sat": "def sat(st: str, a=\"zine\", b=\"cerofilimybazine\"):\n    return st + a == b", "ans_type": "str", "sol_header": "def sol(a=\"zine\", b=\"cerofilimybazine\"):", "sol_docstring": "    \"\"\"Solve simple string addition problem.\"\"\"", "sol_bodies": ["    return b[:len(b) - len(a)]"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrLen:0", "sat": "def sat(s: str, n=1000):\n    return len(s) == n", "ans_type": "str", "sol_header": "def sol(n=1000):", "sol_docstring": "    \"\"\"Find a string of length n\"\"\"", "sol_bodies": ["    return 'a' * n"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrSlice:4", "sat": "def sat(inds: List[int], s=\"kibozekiboze\", target=\"\"):\n    i, j, k = inds\n    return s[i:j:k] == target", "ans_type": "List[int]", "sol_header": "def sol(s=\"kibozekiboze\", target=\"\"):", "sol_docstring": "    \"\"\"Find the three slice indices that give the specific target in string s\"\"\"", "sol_bodies": ["    from itertools import product\n    for i, j, k in product(range(-len(s) - 1, len(s) + 1), repeat=3):\n        try:\n            if s[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrIndex:4", "sat": "def sat(s: str, big_str=\"fatextemedyrotichipicecojon\", index=24):\n    return big_str.index(s) == index", "ans_type": "str", "sol_header": "def sol(big_str=\"fatextemedyrotichipicecojon\", index=24):", "sol_docstring": "    \"\"\"Find a string whose *first* index in big_str is index\"\"\"", "sol_bodies": ["    return big_str[index:]"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrIndex2:4", "sat": "def sat(big_str: str, sub_str=\"nofufaxunetextesitocedezyxuxexyfoquichitiracyquat\", index=185):\n    return big_str.index(sub_str) == index", "ans_type": "str", "sol_header": "def sol(sub_str=\"nofufaxunetextesitocedezyxuxexyfoquichitiracyquat\", index=185):", "sol_docstring": "    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"", "sol_bodies": ["    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrIn:3", "sat": "def sat(s: str, a=\"bafywihequyjicivicharyquynikixuhinyqu\", b=\"syrapetagecvicharyquynirorazecheth\", length=12):\n    return len(s) == length and s in a and s in b", "ans_type": "str", "sol_header": "def sol(a=\"bafywihequyjicivicharyquynikixuhinyqu\", b=\"syrapetagecvicharyquynirorazecheth\", length=12):", "sol_docstring": "    \"\"\"Find a string of length length that is in both strings a and b\"\"\"", "sol_bodies": ["    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrIn2:0", "sat": "def sat(substrings: List[str], s=\"hello\", count=15):\n    return len(substrings) == len(set(substrings)) >= count and all(sub in s for sub in substrings)", "ans_type": "List[str]", "sol_header": "def sol(s=\"hello\", count=15):", "sol_docstring": "    \"\"\"Find a list of >= count distinct strings that are all contained in s\"\"\"", "sol_bodies": ["    return [\"\"] + sorted({s[j:i] for i in range(len(s) + 1) for j in range(i)})"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrCount:4", "sat": "def sat(string: str, substring=\"moz\", count=70, length=210):\n    return string.count(substring) == count and len(string) == length", "ans_type": "str", "sol_header": "def sol(substring=\"moz\", count=70, length=210):", "sol_docstring": "    \"\"\"Find a string with a certain number of copies of a given substring and of a given length\"\"\"", "sol_bodies": ["    c = chr(1 + max(ord(c) for c in (substring or \"a\")))  # a character not in substring\n    return substring * count + (length - len(substring) * count) * '^'"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrJoiner:2", "sat": "def sat(x: str, parts=[], string=\"\"):\n    return x.join(parts) == string", "ans_type": "str", "sol_header": "def sol(parts=[], string=\"\"):", "sol_docstring": "    \"\"\"\n    Find a separator that when used to join a given string gives a certain result.\n    This is related to the previous problem but there are some edge cases that differ.\n    \"\"\"", "sol_bodies": ["    if len(parts) <= 1:\n        return \"\"\n    length = (len(string) - len(\"\".join(parts))) // (len(parts) - 1)\n    start = len(parts[0])\n    return string[start:start + length]"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "StrParts:2", "sat": "def sat(parts: List[str], sep=\"xusoquyvamathila\", string=\"bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji\"):\n    return sep.join(parts) == string and all(sep not in p for p in parts)", "ans_type": "List[str]", "sol_header": "def sol(sep=\"xusoquyvamathila\", string=\"bolifotinuwywyjochxusoquyvamathilazyvuxusoquyvamathilanifajatextethxusoquyvamathilafocharatefymoji\"):", "sol_docstring": "    \"\"\"Find parts that when joined give a specific string.\"\"\"", "sol_bodies": ["    return string.split(sep)"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "ListSetLen:3", "sat": "def sat(li: List[int], dups=23476):\n    return len(set(li)) == len(li) - dups", "ans_type": "List[int]", "sol_header": "def sol(dups=23476):", "sol_docstring": "    \"\"\"Find a list with a certain number of duplicate items\"\"\"", "sol_bodies": ["    return [1] * (dups + 1)"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "ListMul:2", "sat": "def sat(li: List[int], target=[-51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344], n=8):\n    return li * n == target", "ans_type": "List[int]", "sol_header": "def sol(target=[-51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344, -51721, -18394, -51187, -39897, 18547, 42761, -8992, 66683, 78344], n=8):", "sol_docstring": "    \"\"\"Find a list that when multiplied n times gives the target list\"\"\"", "sol_bodies": ["    if n == 0:\n        return []\n    return target[:len(target) // n]"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "ListAt:0", "sat": "def sat(i: int, li=[17, 31, 91, 18, 42, 1, 9], target=18):\n    return li[i] == target", "ans_type": "int", "sol_header": "def sol(li=[17, 31, 91, 18, 42, 1, 9], target=18):", "sol_docstring": "    \"\"\"Find the index of an item in a list. Any such index is fine.\"\"\"", "sol_bodies": ["    return li.index(target)"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "ListNegAt:2", "sat": "def sat(i: int, li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42):\n    return li[i] == target and i < 0", "ans_type": "int", "sol_header": "def sol(li=[-60, 9, 1, -42, 31, 70, 5, 1, 42, -90, -20], target=-42):", "sol_docstring": "    \"\"\"Find the index of an item in a list using negative indexing.\"\"\"", "sol_bodies": ["    return li.index(target) - len(li)"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "ListSlice:3", "sat": "def sat(inds: List[int], li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]):\n    i, j, k = inds\n    return li[i:j:k] == target", "ans_type": "List[int]", "sol_header": "def sol(li=[-72, 70, 50, -41, 94, -82, -74, 8, -23], target=[-82]):", "sol_docstring": "    \"\"\"Find three slice indices to achieve a given list slice\"\"\"", "sol_bodies": ["    from itertools import product\n    for i, j, k in product(range(-len(li) - 1, len(li) + 1), repeat=3):\n        try:\n            if li[i:j:k] == target:\n                return [i, j, k]\n        except (IndexError, ValueError):\n            pass"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "ListIn:1", "sat": "def sat(s: str, a=['xetex', 'jomuboxuc', 'nyfiranuri', 'curu', 'jehykexethinun', 'bumekynuxinit', 'cymelatabegi', 'jumuvufotextasa', 'cotharasyfukakiwoc', 'fuvyvavi', 'gohavelomet', 'hibymomotohywehathi', 'jyzucakaq', 'chihyx', 'wukikogy', 'pegydozetebegafugyf', 'chywadetextekesyjup', 'xysecaw', 'ryzafusul', 'lojychurep', 'vivutolimifa', 'pysiquikywoty', 'thitexturykasoquifet', 'va', 'nagetextilac', 'tex', 'zechocha', 'susatexty', 'ch'], b=['vesaredu', 'textyjun', 'hijilenafotycoch', 'fofytextulidajekymos', 'thudothukuzaxug', 'dythezutolihibinafyj', 'hadid', 'zyly', 'mu', 'chywadetextekesyjup', 'zekyrivequi', 'pebycipohivam', 'texterekuwudut', 'c', 'sanidithuh', 'ritextuchik', 'ny', 'cym', 'cirok', 'kavuquithochazethej', 'zikechep', 'kesitabuduzu', 'duchequ', 'fuluhesowyjugehusab', 'tof', 'tu', 'textichagekochoquovo', 'bo', 'thac', 'hytextac', 'nerehufymex', 'jezyletextiquebositi', 'm', 'kathithowefyvoced', 'rityjivoxadydyzatiq', 'nuxaritutebacygevyq', 'thyjaxirumenaquuxy', 'gizydylot', 'textite', 'guchikek', 'fas', 'pabipapiro', 'fechiduchu', 'pexijis', 'gojep', 'quinatextit', 'chaqu', 'xyxyjos', 'pudibothytigiwumucex', 'josadubizy', 'jy', 'komazibomapothequev', 'licogatextuliletuxi', 'gus', 'nylyxyjibikimet', 'tafo']):\n    return s in a and s in b", "ans_type": "str", "sol_header": "def sol(a=['xetex', 'jomuboxuc', 'nyfiranuri', 'curu', 'jehykexethinun', 'bumekynuxinit', 'cymelatabegi', 'jumuvufotextasa', 'cotharasyfukakiwoc', 'fuvyvavi', 'gohavelomet', 'hibymomotohywehathi', 'jyzucakaq', 'chihyx', 'wukikogy', 'pegydozetebegafugyf', 'chywadetextekesyjup', 'xysecaw', 'ryzafusul', 'lojychurep', 'vivutolimifa', 'pysiquikywoty', 'thitexturykasoquifet', 'va', 'nagetextilac', 'tex', 'zechocha', 'susatexty', 'ch'], b=['vesaredu', 'textyjun', 'hijilenafotycoch', 'fofytextulidajekymos', 'thudothukuzaxug', 'dythezutolihibinafyj', 'hadid', 'zyly', 'mu', 'chywadetextekesyjup', 'zekyrivequi', 'pebycipohivam', 'texterekuwudut', 'c', 'sanidithuh', 'ritextuchik', 'ny', 'cym', 'cirok', 'kavuquithochazethej', 'zikechep', 'kesitabuduzu', 'duchequ', 'fuluhesowyjugehusab', 'tof', 'tu', 'textichagekochoquovo', 'bo', 'thac', 'hytextac', 'nerehufymex', 'jezyletextiquebositi', 'm', 'kathithowefyvoced', 'rityjivoxadydyzatiq', 'nuxaritutebacygevyq', 'thyjaxirumenaquuxy', 'gizydylot', 'textite', 'guchikek', 'fas', 'pabipapiro', 'fechiduchu', 'pexijis', 'gojep', 'quinatextit', 'chaqu', 'xyxyjos', 'pudibothytigiwumucex', 'josadubizy', 'jy', 'komazibomapothequev', 'licogatextuliletuxi', 'gus', 'nylyxyjibikimet', 'tafo']):", "sol_docstring": "    \"\"\"Find an item that is in both lists a and b\"\"\"", "sol_bodies": ["    return next(s for s in b if s in a)"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "IntNeg:0", "sat": "def sat(x: int, a=93252338):\n    return -x == a", "ans_type": "int", "sol_header": "def sol(a=93252338):", "sol_docstring": "    \"\"\"Solve a unary negation problem\"\"\"", "sol_bodies": ["    return - a"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "IntSum:0", "sat": "def sat(x: int, a=1073258, b=72352549):\n    return a + x == b", "ans_type": "int", "sol_header": "def sol(a=1073258, b=72352549):", "sol_docstring": "    \"\"\"Solve a sum problem\"\"\"", "sol_bodies": ["    return b - a"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "IntSub:2", "sat": "def sat(x: int, a=9688203125538303, b=-293093369321912):\n    return x - a == b", "ans_type": "int", "sol_header": "def sol(a=9688203125538303, b=-293093369321912):", "sol_docstring": "    \"\"\"Solve a subtraction problem\"\"\"", "sol_bodies": ["    return a + b"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "IntSub2:4", "sat": "def sat(x: int, a=-8783800228130606, b=-508993556991975):\n    return a - x == b", "ans_type": "int", "sol_header": "def sol(a=-8783800228130606, b=-508993556991975):", "sol_docstring": "    \"\"\"Solve a subtraction problem\"\"\"", "sol_bodies": ["    return a - b"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "IntMul:3", "sat": "def sat(n: int, a=-141336, b=72):\n    return b * n + (a % b) == a", "ans_type": "int", "sol_header": "def sol(a=-141336, b=72):", "sol_docstring": "    \"\"\"Solve a multiplication problem\"\"\"", "sol_bodies": ["    return a // b"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "IntDiv:2", "sat": "def sat(n: int, a=12, b=-9988218457242775):\n    return b // n == a", "ans_type": "int", "sol_header": "def sol(a=12, b=-9988218457242775):", "sol_docstring": "    \"\"\"Solve a division problem\"\"\"", "sol_bodies": ["    if a == 0:\n        return 2 * b\n    for n in [b // a, b // a - 1, b // a + 1]:\n        if b // n == a:\n            return n"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "IntDiv2:1", "sat": "def sat(n: int, a=-3411193412414137, b=-9070455318026063):\n    return n // b == a", "ans_type": "int", "sol_header": "def sol(a=-3411193412414137, b=-9070455318026063):", "sol_docstring": "    \"\"\"Find n that when divided by b is a\"\"\"", "sol_bodies": ["    return a * b"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "IntSquareRoot:1", "sat": "def sat(x: int, a=2617350631613713636):\n    return x ** 2 == a", "ans_type": "int", "sol_header": "def sol(a=2617350631613713636):", "sol_docstring": "    \"\"\"Compute an integer that when squared equals perfect-square a.\"\"\"", "sol_bodies": ["    return int(a ** 0.5)"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "FloatSquareRoot:3", "sat": "def sat(x: float, a=2732656229):\n    return abs(x ** 2 - a) < 10 ** -3", "ans_type": "float", "sol_header": "def sol(a=2732656229):", "sol_docstring": "    \"\"\"Find a number that when squared is close to a.\"\"\"", "sol_bodies": ["    return a ** 0.5"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "FloatNegSquareRoot:2", "sat": "def sat(x: float, a=1363713245):\n    return abs(x ** 2 - a) < 10 ** -3 and x < 0", "ans_type": "float", "sol_header": "def sol(a=1363713245):", "sol_docstring": "    \"\"\"Find a negative number that when squared is close to a.\"\"\"", "sol_bodies": ["    return -a ** 0.5"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "Tutorial1:0", "sat": "def sat(s: str):\n    return \"Hello \" + s == \"Hello world\"", "ans_type": "str", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a string that when concatenated onto 'Hello ' gives 'Hello world'.\"\"\"", "sol_bodies": ["    return \"world\""], "module": "tutorial.py", "notes": "", "weight": 1.0}, {"name": "Tutorial2:0", "sat": "def sat(s: str):\n    return \"Hello \" + s[::-1] == \"Hello world\"", "ans_type": "str", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a string that when reversed and concatenated onto 'Hello ' gives 'Hello world'.\"\"\"", "sol_bodies": ["    return \"world\"[::-1]"], "module": "tutorial.py", "notes": "", "weight": 1.0}, {"name": "Tutorial3:0", "sat": "def sat(x: List[int]):\n    return len(x) == 2 and sum(x) == 3", "ans_type": "List[int]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a list of two integers whose sum is 3.\"\"\"", "sol_bodies": ["    return [1, 2]"], "module": "tutorial.py", "notes": "", "weight": 1.0}, {"name": "Tutorial4:0", "sat": "def sat(s: List[str]):\n    return len(set(s)) == 1000 and all((x.count(\"a\") > x.count(\"b\")) and ('b' in x) for x in s)", "ans_type": "List[str]", "sol_header": "def sol():", "sol_docstring": "    \"\"\"Find a list of 1000 distinct strings which each have more 'a's than 'b's and at least one 'b'.\"\"\"", "sol_bodies": ["    return [\"a\" * (i + 2) + \"b\" for i in range(1000)]"], "module": "tutorial.py", "notes": "", "weight": 1.0}]