[{"name": "ReverseLifeStep:3", "sat": "def sat(position: List[List[int]], target=[[3, 3]]):\n    live = {x + y * 1j for x, y in position}  # complex numbers encode live cells\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n    visible = {z + d for z in live for d in deltas}\n    next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n    return next_step == {x + y * 1j for x, y in target}", "ans_type": "List[List[int]]", "sol_header": "def sol(target=[[3, 3]]):", "sol_docstring": "    \"\"\"\n    Given a target pattern in Conway's Game of Life (see https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life ),\n    specified by [x,y] coordinates of live cells, find a position that leads to that pattern on the next step.\n    \"\"\"", "sol_bodies": ["    # fixed-temperature MC optimization\n    TEMP = 0.05\n    import random\n    rand = random.Random(0)  # set seed but don't interfere with other random uses\n    target = {x + y * 1j for x, y in target}\n    deltas = (1j, -1j, 1, -1, 1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j)\n\n    def distance(live):\n        visible = {z + d for z in live for d in deltas}\n        next_step = {z for z in visible if sum(z + d in live for d in deltas) in ([2, 3] if z in live else [3])}\n        return len(next_step.symmetric_difference(target))\n\n    for step in range(10 ** 5):\n        if step % 10000 == 0:\n            pos = target.copy()  # start with the target position\n            cur_dist = distance(pos)\n\n        if cur_dist == 0:\n            return [[int(z.real), int(z.imag)] for z in pos]\n        z = rand.choice([z + d for z in pos.union(target) for d in deltas])\n        dist = distance(pos.symmetric_difference({z}))\n        if rand.random() <= TEMP ** (dist - cur_dist):\n            pos.symmetric_difference_update({z})\n            cur_dist = dist\n    print('Failed', len(target), step)"], "module": "conways_game_of_life.py", "notes": "Unsolvable for \"Garden of Eden\" positions, but we only generate solvable examples", "weight": 1.0}, {"name": "GCD:2", "sat": "def sat(n: int, a=232610, b=3131721474, lower_bound=15000):\n    return a % n == 0 and b % n == 0 and n >= lower_bound", "ans_type": "int", "sol_header": "def sol(a=232610, b=3131721474, lower_bound=15000):", "sol_docstring": "    \"\"\"Find a large common divisor of two integers.\"\"\"", "sol_bodies": ["    m, n = min(a, b), max(a, b)\n    while m > 0:\n        m, n = n % m, m\n    return n", "    def gcd(m, n):\n        if m > n:\n            return gcd(n, m)\n        if m == 0:\n            return n\n        return gcd(n % m, m)\n\n    return gcd(a, b)"], "module": "number_theory.py", "notes": "[Greatest Common Divisor](https://en.wikipedia.org/w/index.php?title=Greatest_common_divisor&oldid=990943381)\n(GCD)\n\nSee also the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)", "weight": 1.0}, {"name": "Znam:3", "sat": "def sat(li: List[int], k=8):\n    def prod(nums):\n        ans = 1\n        for i in nums:\n            ans *= i\n        return ans\n\n    return min(li) > 1 and len(li) == k and all((1 + prod(li[:i] + li[i + 1:])) % li[i] == 0 for i in range(k))", "ans_type": "List[int]", "sol_header": "def sol(k=8):", "sol_docstring": "    \"\"\"Find k positive integers such that each integer divides (the product of the rest plus 1).\"\"\"", "sol_bodies": ["    n = 2\n    prod = 1\n    ans = []\n    while len(ans) < k:\n        ans.append(n)\n        prod *= n\n        n = prod + 1\n    return ans"], "module": "number_theory.py", "notes": "[Znam's Problem](https://en.wikipedia.org/wiki/Zn%C3%A1m%27s_problem)\n\nFor example [2, 3, 7, 47, 395] is a solution for k=5", "weight": 1.0}, {"name": "VerbalArithmetic:2", "sat": "def sat(li: List[int], words=['GREEN', 'ORANGE', 'COLORS']):\n    assert len(li) == len(words) and all(i > 0 and len(str(i)) == len(w) for i, w in zip(li, words))\n    assert len({c for w in words for c in w}) == len({(d, c) for i, w in zip(li, words) for d, c in zip(str(i), w)})\n    return sum(li[:-1]) == li[-1]", "ans_type": "List[int]", "sol_header": "def sol(words=['GREEN', 'ORANGE', 'COLORS']):", "sol_docstring": "    \"\"\"\n    Find a list of integers corresponding to the given list of strings substituting a different digit for each\n    character, so that the last string corresponds to the sum of the previous numbers.\n    \"\"\"", "sol_bodies": ["    pi = list(range(10))  # permutation\n    letters = []\n    order = {}\n    steps = []\n    tens = 1\n    for col in range(1, 1 + max(len(w) for w in words)):\n        for w in words:\n            is_tot = (w is words[-1])\n            if len(w) >= col:\n                c = w[-col]\n                if c in order:\n                    if is_tot:\n                        kind = \"check\"\n                    else:\n                        kind = \"seen\"\n                else:\n                    if is_tot:\n                        kind = \"derive\"\n                    else:\n                        kind = \"add\"\n                    order[c] = len(letters)\n                    letters.append(c)\n                steps.append((kind, order[c], tens))\n        tens *= 10\n\n    inits = [any(w[0] == c for w in words) for c in letters]\n\n    def helper(pos, delta):  # on success, returns True and pi has the correct values\n        if pos == len(steps):\n            return delta == 0\n\n        kind, i, tens = steps[pos]\n\n        if kind == \"seen\":\n            return helper(pos + 1, delta + tens * pi[i])\n\n        if kind == \"add\":\n            for j in range(i, 10):\n                if pi[j] != 0 or not inits[i]:  # not adding a leading 0\n                    pi[i], pi[j] = pi[j], pi[i]\n                    if helper(pos + 1, delta + tens * pi[i]):\n                        return True\n                    pi[i], pi[j] = pi[j], pi[i]\n            return False\n        if kind == \"check\":\n            delta -= tens * pi[i]\n            return (delta % (10 * tens)) == 0 and helper(pos + 1, delta)\n\n        assert kind == \"derive\"\n        digit = (delta % (10 * tens)) // tens\n        if digit == 0 and inits[i]:\n            return False  # would be a leading 0\n        j = pi.index(digit)\n        if j < i:\n            return False  # already used\n        pi[i], pi[j] = pi[j], pi[i]\n        if helper(pos + 1, delta - tens * digit):\n            return True\n        pi[i], pi[j] = pi[j], pi[i]\n        return False\n\n    assert helper(0, 0)\n    return [int(\"\".join(str(pi[order[c]]) for c in w)) for w in words]"], "module": "classic_puzzles.py", "notes": "Find a substitution of digits for characters to make the numbers add up in a sum like this:\nSEND + MORE = MONEY\n\nThe first digit in any number cannot be 0. In this example the solution is `9567 + 1085 = 10652`.\nSee [Wikipedia article](https://en.wikipedia.org/wiki/Verbal_arithmetic)", "weight": 1.0}, {"name": "DominoTile:4", "sat": "def sat(squares: List[List[int]], m=41, n=12, target=492):\n    covered = []\n    for i1, j1, i2, j2 in squares:\n        assert (0 <= i1 <= i2 < m) and (0 <= j1 <= j2 < n) and (j2 - j1 + i2 - i1 == 1)\n        covered += [(i1, j1), (i2, j2)]\n    return len(set(covered)) == len(covered) == target", "ans_type": "List[List[int]]", "sol_header": "def sol(m=41, n=12, target=492):", "sol_docstring": "    \"\"\"Tile an m x n checkerboard with 2 x 1 tiles. The solution is a list of fourtuples [i1, j1, i2, j2] with\n    i2 == i1 and j2 == j1 + 1 or i2 == i1 + 1 and j2 == j1 with no overlap.\"\"\"", "sol_bodies": ["    if m % 2 == 0:\n        ans = [[i, j, i + 1, j] for i in range(0, m, 2) for j in range(n)]\n    elif n % 2 == 0:\n        ans = [[i, j, i, j + 1] for i in range(m) for j in range(0, n, 2)]\n    else:\n        ans = [[i, j, i + 1, j] for i in range(1, m, 2) for j in range(n)]\n        ans += [[0, j, 0, j + 1] for j in range(0, n - 1, 2)]\n    return ans"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 50 A](https://codeforces.com/problemset/problem/50/A)", "weight": 1.0}, {"name": "ArithmeticSequence:4", "sat": "def sat(x: List[int], a=-44635, s=5046, e=503563):\n    return x[0] == a and x[-1] <= e and (x[-1] + s > e) and all([x[i] + s == x[i + 1] for i in range(len(x) - 1)])", "ans_type": "List[int]", "sol_header": "def sol(a=-44635, e=503563, s=5046):", "sol_docstring": "    \"\"\"Create a list that is a subrange of an arithmetic sequence.\"\"\"", "sol_bodies": ["    return list(range(a, e + 1, s))"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "StrIn:4", "sat": "def sat(s: str, a=\"diquatextaxubowafucevyhuquuthexitacavobychajexytextug\", b=\"thachevolatvyhuquuthexitacavobyjokobuchudymal\", length=20):\n    return len(s) == length and s in a and s in b", "ans_type": "str", "sol_header": "def sol(a=\"diquatextaxubowafucevyhuquuthexitacavobychajexytextug\", b=\"thachevolatvyhuquuthexitacavobyjokobuchudymal\", length=20):", "sol_docstring": "    \"\"\"Find a string of length length that is in both strings a and b\"\"\"", "sol_bodies": ["    for i in range(len(a) - length + 1):\n        if a[i:i + length] in b:\n            return a[i:i + length]"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "MaxDelta:4", "sat": "def sat(n: int, pairs=[[459604, 0], [364611, 68505], [562652, 512251], [668655, 471975], [464486, 626280], [138684, 177065], [163296, 68630], [188271, 104677], [367839, 338137], [73022, 362103], [464143, 484458], [214935, 189299], [643725, 283515], [908210, 541732], [710201, 234839], [854230, 34479], [3288, 675724], [846637, 396244], [0, 2526576]]):\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success", "ans_type": "int", "sol_header": "def sol(pairs=[[459604, 0], [364611, 68505], [562652, 512251], [668655, 471975], [464486, 626280], [138684, 177065], [163296, 68630], [188271, 104677], [367839, 338137], [73022, 362103], [464143, 484458], [214935, 189299], [643725, 283515], [908210, 541732], [710201, 234839], [854230, 34479], [3288, 675724], [846637, 396244], [0, 2526576]]):", "sol_docstring": "    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"", "sol_bodies": ["    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 116 A](https://codeforces.com/problemset/problem/116/A)", "weight": 1.0}, {"name": "UncrossedKnightsPath:0", "sat": "def sat(path: List[List[int]], m=8, n=8, target=35):\n    def legal_move(m):\n        (a, b), (i, j) = m\n        return {abs(i - a), abs(j - b)} == {1, 2}\n\n    def legal_quad(m1, m2):  # non-overlapping test: parallel or bounding box has (width - 1) * (height - 1) >= 5\n        (i1, j1), (i2, j2) = m1\n        (a1, b1), (a2, b2) = m2\n        return (len({(i1, j1), (i2, j2), (a1, b1), (a2, b2)}) < 4  # adjacent edges in path, ignore\n                or (i1 - i2) * (b1 - b2) == (j1 - j2) * (a1 - a2)  # parallel\n                or (max(a1, a2, i1, i2) - min(a1, a2, i1, i2)) * (max(b1, b2, j1, j2) - min(b1, b2, j1, j2)) >= 5\n                # far\n                )\n\n    assert all(i in range(m) and j in range(n) for i, j in path), \"move off board\"\n    assert len({(i, j) for i, j in path}) == len(path), \"visited same square twice\"\n\n    moves = list(zip(path, path[1:]))\n    assert all(legal_move(m) for m in moves), \"illegal move\"\n    assert all(legal_quad(m1, m2) for m1 in moves for m2 in moves), \"intersecting move pair\"\n\n    return len(path) >= target", "ans_type": "List[List[int]]", "sol_header": "def sol(m=8, n=8, target=35):", "sol_docstring": "    \"\"\"Find a long (open) tour of knight moves on an m x n chess-board whose edges don't cross.\"\"\"", "sol_bodies": [], "module": "chess.py", "notes": "Uncrossed Knights Path (known solvable, but no solution given)\n\nThe goal of these problems is to match the nxn_records from [http://ukt.alex-black.ru/](http://ukt.alex-black.ru/)\n(accessed 2020-11-29).\n\nA more precise description is in this\n[Wikipedia article](https://en.wikipedia.org/w/index.php?title=Longest_uncrossed_knight%27s_path).", "weight": 1.0}, {"name": "HalfPairs:0", "sat": "def sat(ans: List[List[int]], target=17):\n    for i in range(len(ans)):\n        a, b = ans[i]\n        if b - a >= 2:\n            target -= 1\n    return target == 0", "ans_type": "List[List[int]]", "sol_header": "def sol(target=17):", "sol_docstring": "    \"\"\"\n    Find a list of pairs of integers where the number of pairs in which the second number is more than\n    two greater than the first number is a given constant\n    \"\"\"", "sol_bodies": ["    return [[0, 2]] * target"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 467 A](https://codeforces.com/problemset/problem/467/A)", "weight": 1.0}, {"name": "InvertIndices:3", "sat": "def sat(indexes: List[int], target=[47, 10, 38, 39, 63, 9, 20, 31, 3, 42, 24, 4, 48, 25, 40, 52, 33, 58, 12, 5, 35, 51, 17, 6, 57, 60, 56, 61, 32, 64, 13, 59, 27, 50, 43, 11, 55, 29, 16, 19, 45, 7, 26, 1, 49, 53, 36, 18, 34, 22, 41, 46, 23, 15, 2, 14, 21, 28, 44, 54, 62, 30, 37, 8]):\n    for i in range(1, len(target) + 1):\n        if target[indexes[i - 1] - 1] != i:\n            return False\n    return True", "ans_type": "List[int]", "sol_header": "def sol(target=[47, 10, 38, 39, 63, 9, 20, 31, 3, 42, 24, 4, 48, 25, 40, 52, 33, 58, 12, 5, 35, 51, 17, 6, 57, 60, 56, 61, 32, 64, 13, 59, 27, 50, 43, 11, 55, 29, 16, 19, 45, 7, 26, 1, 49, 53, 36, 18, 34, 22, 41, 46, 23, 15, 2, 14, 21, 28, 44, 54, 62, 30, 37, 8]):", "sol_docstring": "    \"\"\"Given a list of integers representing a permutation, invert the permutation.\"\"\"", "sol_bodies": [], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 136 A](https://codeforces.com/problemset/problem/136/A)", "weight": 1.0}, {"name": "DecreasingCountComparison:3", "sat": "def sat(n: int, scores=[36, 27, 24, 19, 15, 15, 8, 8, 5], k=4):\n    assert all(scores[i] >= scores[i + 1] for i in range(len(scores) - 1)), \"Hint: scores are non-decreasing\"\n    return all(s >= scores[k] and s > 0 for s in scores[:n]) and all(s < scores[k] or s <= 0 for s in scores[n:])", "ans_type": "int", "sol_header": "def sol(scores=[36, 27, 24, 19, 15, 15, 8, 8, 5], k=4):", "sol_docstring": "    \"\"\"\n    Given a list of non-increasing integers and given an integer k, determine how many positive integers in the list\n    are at least as large as the kth.\n    \"\"\"", "sol_bodies": ["    threshold = max(scores[k], 1)\n    return sum(s >= threshold for s in scores)"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 158 A](https://codeforces.com/problemset/problem/158/A)", "weight": 1.0}, {"name": "ListPosSum:4", "sat": "def sat(x: List[int], n=9909, s=88140438):\n    return len(x) == n and sum(x) == s and all([a > 0 for a in x])", "ans_type": "List[int]", "sol_header": "def sol(n=9909, s=88140438):", "sol_docstring": "    \"\"\"Find a list of n non-negative integers that sum up to s\"\"\"", "sol_bodies": ["    x = [1] * n\n    x[0] = s - n + 1\n    return x"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "FloatWithDecimalValue:2", "sat": "def sat(z: float, v=9, d=1e+83):\n    return int(z * 1 / d % 10) == v", "ans_type": "float", "sol_header": "def sol(v=9, d=1e+83):", "sol_docstring": "    \"\"\"Create a float with a specific decimal.\"\"\"", "sol_bodies": ["    return v * d"], "module": "basic.py", "notes": "", "weight": 1.0}, {"name": "MaxDelta:3", "sat": "def sat(n: int, pairs=[[0, 0]]):\n    assert sum(p - m for p, m in pairs) == 0, \"oo\"\n    tot = 0\n    success = False\n    for p, m in pairs:\n        tot -= m\n        tot += p\n        assert tot <= n\n        if tot == n:\n            success = True\n    return success", "ans_type": "int", "sol_header": "def sol(pairs=[[0, 0]]):", "sol_docstring": "    \"\"\"\n    Given a sequence of integer pairs, p_i, m_i, where \\sum p_i-m_i = 0, find the maximum value, over t, of\n    p_{t+1} + \\sum_{i=1}^t p_i - m_i\n    \"\"\"", "sol_bodies": ["    tot = 0\n    n = 0\n    for p, m in pairs:\n        tot += p - m\n        if tot > n:\n            n = tot\n    return n"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 116 A](https://codeforces.com/problemset/problem/116/A)", "weight": 1.0}, {"name": "StrIndex2:1", "sat": "def sat(big_str: str, sub_str=\"quadox\", index=75):\n    return big_str.index(sub_str) == index", "ans_type": "str", "sol_header": "def sol(sub_str=\"quadox\", index=75):", "sol_docstring": "    \"\"\"Find a string whose *first* index of sub_str is index\"\"\"", "sol_bodies": ["    i = ord('A')\n    while chr(i) in sub_str:\n        i += 1\n    return chr(i) * index + sub_str"], "module": "trivial_inverse.py", "notes": "", "weight": 0.2}, {"name": "CheckersPosition:3", "sat": "def sat(position: List[List[int]], transcript=[[[3, 1], [1, 3]]]):\n    board = {(x, y): 0 for x in range(8) for y in range(8) if (x + y) % 2 == 0}  # empty board, 0 = empty\n    for x, y, p in position:\n        assert -2 <= p <= 2 and board[x, y] == 0  # -1, 1 is regular piece, -2, 2 is king\n        board[x, y] = p\n\n    def has_a_jump(x, y):\n        p = board[x, y]  # piece to move\n        deltas = [(dx, dy) for dx in [-1, 1] for dy in [-1, 1] if dy != -p]  # don't check backwards for non-kings\n        return any(board.get((x + 2 * dx, y + 2 * dy)) == 0 and board[x + dx, y + dy] * p < 0 for dx, dy in deltas)\n\n    sign = 1  # player 1 moves first\n    for move in transcript:\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = board[start]  # piece to move\n        assert p * sign > 0, \"Moving square must be non-empty and players must be alternate signs\"\n        assert all(board[x, y] == 0 for x, y in move if [x, y] != move[0]), \"Moved to an occupied square\"\n\n        for (x1, y1), (x2, y2) in zip(move, move[1:]):\n            assert abs(p) != 1 or (y2 - y1) * p > 0, \"Non-kings can only move forward (in direction of sign)\"\n            if abs(x2 - x1) == 1:  # non-jump\n                assert not any(has_a_jump(*a) for a in board if board[a] * p > 0), \"Must make a jump if possible\"\n                break\n            mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n            assert board[mid] * p < 0, \"Can only jump over piece of opposite sign\"\n            board[mid] = 0\n        board[start], board[end] = 0, p\n        assert abs(x2 - x1) == 1 or not has_a_jump(*end)\n        if abs(p) == 1 and any(y in {0, 7} for x, y in move[1:]):\n            board[end] *= 2  # king me at the end of turn after any jumps are done!\n        sign *= -1\n\n    return True", "ans_type": "List[List[int]]", "sol_header": "def sol(transcript=[[[3, 1], [1, 3]]]):", "sol_docstring": "    \"\"\"\n    You are given a partial transcript a checkers game. Find an initial position such that the transcript\n    would be a legal set of moves. The board positions are [x, y] pairs with 0 <= x, y < 8 and x + y even.\n    There are two players which we call -1 and 1 for convenience, and player 1 must move first in transcript.\n    The initial position is represented as a list [x, y, piece] where piece means:\n    * 0 is empty square\n    * 1 or -1 is piece that moves only in the y = 1 or y = -1 dir, respectively\n    * 2 or -2 is king for player 1 or player 2 respectively\n\n    Additional rules:\n    * You must jump if you can, and you must continue jumping until one can't any longer.\n    * You cannot start the position with any non-kings on your last rank.\n    * Promotion happens after the turn ends\n    \"\"\"", "sol_bodies": ["    START_PLAYER = 1  # assumed\n\n    class InitOpts:\n        def __init__(self, x, y):\n            self.x, self.y = x, y\n            self.opts = {-2, -1, 0, 1, 2}\n            if y == 0:\n                self.opts.remove(-1)\n            if y == 7:\n                self.opts.remove(1)\n            self.promoted = 2 ** 63  # on which step was it promoted t >= 0\n            self.jumped = 2 ** 63  # on which step was it jumped t >= 0\n\n    # def board2str(board):  # for debugging\n    #     mapping = \".bBWw\"\n    #     ans = \"\"\n    #     for y in range(7, -1, -1):\n    #         ans += \"\".join(\" \" if (x+y)%2 else mapping[board[x,y]] for x in range(8)) + \"\\n\"\n    #     return ans\n\n    init_opts = {(x, y): InitOpts(x, y) for x in range(8) for y in range(8) if (x + y) % 2 == 0}\n    # board = {(x, y): (1 if y < 3 else -1 if y > 4 else 0) for x in range(8) for y in range(8) if\n    #          (x + y) % 2 == 0}  # new board\n\n    transcript = [[tuple(a) for a in move] for move in transcript]\n\n    permuted_opts = init_opts.copy()\n    sign = START_PLAYER\n    for t, move in enumerate(transcript):\n        start, end = tuple(move[0]), tuple(move[-1])\n        p = permuted_opts[start]  # opts to move\n        assert p.jumped >= t\n        p.opts -= {-sign, -2 * sign, 0}\n        if any((y2 - y1) * sign < 0 for (x1, y1), (x2, y2) in zip(move, move[1:])):  # backward move!\n            if p.promoted >= t:\n                p.opts -= {sign}  # must be a king!\n\n        for a, b in zip(move, move[1:]):\n            if permuted_opts[b].jumped >= t:\n                permuted_opts[b].opts -= {-2, -1, 1, 2}  # must be empty\n            assert permuted_opts[a].jumped >= t\n            permuted_opts[a], permuted_opts[b] = permuted_opts[b], permuted_opts[a]\n            # board[a], board[b] = board[b], board[a]\n            (x1, y1), (x2, y2) = a, b\n            if abs(x2 - x1) == 2:  # jump\n                mid = ((x1 + x2) // 2, (y1 + y2) // 2)\n                assert permuted_opts[mid].jumped >= t\n                permuted_opts[mid].opts -= {0, sign, 2 * sign}  # Can only jump over piece of opposite sign\n                permuted_opts[mid].jumped = t\n                # board[mid] = 0\n\n        if any(y in {0, 7} for x, y in move[1:]):\n            if p.promoted > t:\n                p.promoted = t\n            # if abs(board[x2, y2]) == 1:\n            #     board[x2, y2] *= 2\n\n        sign *= -1\n\n    for y in range(7, -1, -1):\n        for x in range(8):\n            if (x, y) in init_opts:\n                s = init_opts[x, y].opts\n                if {1, 2} <= s:\n                    s.remove(2)\n                if {-1, -2} <= s:\n                    s.remove(-2)\n\n    def helper():  # returns True if success and store everything, otherwise None\n        my_opts = init_opts.copy()\n        sign = START_PLAYER  # player 1 always starts\n\n        for t, move in enumerate(transcript):\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                check_no_jumps = [a for a, p in my_opts.items() if p.jumped >= t and p.opts <= {sign, 2 * sign}]\n            else:\n                for a, b in zip(move, move[1:]):\n                    my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n                check_no_jumps = [b]\n\n            for x, y in check_no_jumps:\n                p = my_opts[x, y]\n                [o] = p.opts\n                assert o * sign > 0\n                dys = [o] if (abs(o) == 1 and p.promoted >= t) else [-1, 1]  # only check forward jumps\n                for dx in [-1, 1]:\n                    for dy in dys:\n                        target_o = my_opts.get((x + 2 * dx, y + 2 * dy))\n                        if target_o is not None and (0 in target_o.opts or target_o.jumped < t):\n                            mid_o = my_opts[x + dx, y + dy]\n                            if mid_o.jumped > t and mid_o.opts <= {-sign, -2 * sign}:  # ok if jumped at t\n                                if target_o.jumped < t or target_o.opts == {0}:\n                                    return False\n                                old_opts = target_o.opts\n                                for v in target_o.opts:\n                                    if v != 0:\n                                        target_o.opts = {v}\n                                        h = helper()\n                                        if h:\n                                            return True\n                                target_o.opts = old_opts\n                                return False\n\n            if abs(move[0][0] - move[1][0]) == 1:  # not a jump\n                a, b = move[0], move[1]\n                my_opts[a], my_opts[b] = my_opts[b], my_opts[a]\n\n            sign *= -1\n        return True\n\n    res = helper()\n    assert res\n\n    def get_opt(opts):\n        if 0 in opts.opts:\n            return 0\n        assert len(opts.opts) == 1\n        return list(opts.opts)[0]\n\n    return [[x, y, get_opt(opts)] for (x, y), opts in init_opts.items()]"], "module": "ICPC.py", "notes": "Inspired by\n[ICPC 2019 Problem C: Checks Post Facto](https://icpc.global/worldfinals/problems/2019%20ACM-ICPC%20World%20Finals/icpc2019.pdf)\n\nNobody solved this problem during the competition -- it is pretty difficult!", "weight": 1.0}, {"name": "BillSums:4", "sat": "def sat(bills: List[int], denominations=[1, 10, 23, 49], n=74, max_len=4):\n    return sum(bills) == n and all(b in denominations for b in bills) and len(bills) <= max_len", "ans_type": "List[int]", "sol_header": "def sol(denominations=[1, 10, 23, 49], n=74, max_len=4):", "sol_docstring": "    \"\"\"\n    Find the shortest sequence (length <= max_len) that sum to n, where each number is in denominations\n    \"\"\"", "sol_bodies": ["    \"\"\"\n    This solution uses dynamic programming, I believe it could be further sped up without having to count\n    all the way up to denominations.\n    \"\"\"\n    denominations = sorted(set(denominations)) # remove duplicates\n    seqs = [[0 for _ in denominations] +[0]]  # vectors\n    for i in range(1, n + 1):\n        _, j, k = min((seqs[i - k][-1], j, k) for j, k in enumerate(denominations) if k <= i)\n        s = seqs[i - k]\n        seqs.append([*s[:j], s[j] + 1, *s[j + 1:-1], s[-1] + 1])\n\n    return [k for k, count in zip(denominations, seqs[-1]) for _ in range(count)]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 996 A](https://codeforces.com/problemset/problem/996/A)\n\nWe make it much harder when the denominations are non-American so the greedy algorithm doesn't work.", "weight": 1.0}, {"name": "CombinationLock:1", "sat": "def sat(states: List[str], start=\"77872\", combo=\"43506\", target_len=16):\n    assert all(len(s) == len(start) for s in states) and all(c in \"0123456789\" for s in states for c in s)\n    for a, b in zip([start] + states, states + [combo]):\n        assert sum(i != j for i, j in zip(a, b)) == 1\n        assert all(abs(int(i) - int(j)) in {0, 1, 9} for i, j in zip(a, b))\n\n    return len(states) <= target_len", "ans_type": "List[str]", "sol_header": "def sol(start=\"77872\", combo=\"43506\", target_len=16):", "sol_docstring": "    \"\"\"\n    Shortest Combination Lock Path\n\n    Given a starting a final lock position, find the (minimal) intermediate states, where each transition\n    involves increasing or decreasing a single digit (mod 10).\n\n    Example:\n    start = \"012\"\n    combo = \"329\"\n    output: ['112', '212', '312', '322', '321', '320']\n    \"\"\"", "sol_bodies": ["    n = len(start)\n    ans = []\n    a, b = [[int(c) for c in x] for x in [start, combo]]\n    for i in range(n):\n        while a[i] != b[i]:\n            a[i] = (a[i] - 1 if (a[i] - b[i]) % 10 < 5 else a[i] + 1) % 10\n            if a != b:\n                ans.append(\"\".join(str(i) for i in a))\n    return ans"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 540 A](https://codeforces.com/problemset/problem/540/A)", "weight": 1.0}, {"name": "SameDifferent:0", "sat": "def sat(lists: List[List[int]], items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):\n    a, b = lists\n    assert len(a) == len(b) == length\n    assert len(set(a)) == len(a)\n    assert len(set(b)) == 1\n    for i in a + b:\n        assert (a + b).count(i) <= items.count(i)\n    return True", "ans_type": "List[List[int]]", "sol_header": "def sol(items=[5, 4, 9, 4, 5, 5, 5, 1, 5, 5], length=4):", "sol_docstring": "    \"\"\"\n    Given a list of integers and a target length, create of the given length such that:\n        * The first list must be all different numbers.\n        * The second must be all the same number.\n        * The two lists together comprise a sublist of all the list items\n    \"\"\"", "sol_bodies": ["    from collections import Counter\n    [[a, count]] = Counter(items).most_common(1)\n    assert count >= length\n    seen = {a}\n    dedup = [i for i in items if i not in seen and not seen.add(i)]\n    return [(dedup + [a])[:length], [a] * length]"], "module": "codeforces.py", "notes": "Inspired by [Codeforces Problem 1335 C](https://codeforces.com/problemset/problem/1335/C)", "weight": 1.0}]